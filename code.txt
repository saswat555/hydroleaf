======= Directory: tests =======

----- tests/test_detailed_cases.py -----
# tests/test_detailed_cases.py

import asyncio
import importlib
import os

import pytest
import httpx
from fastapi import HTTPException

from app.services.device_controller import DeviceController
from app.services.llm import call_llm_async, USE_OLLAMA
from app.services.supply_chain_service import extract_json_from_response
from app.services.llm import parse_json_response, build_dosing_prompt
from app.models import Device

# -----------------------------
# 1) Discover fallback ’ip’
# -----------------------------
@pytest.mark.asyncio
async def test_discover_fallback_ip_strips_http_prefix(monkeypatch):
    class DummyRes:
        def __init__(self, code, data):
            self.status_code = code
            self._json = data
        def json(self):
            return self._json

    class FakeCli:
        def __init__(self, *a, **k): pass
        async def __aenter__(self): return self
        async def __aexit__(self, *a): pass
        async def get(self, path, *a, **k):
            if path == "/discovery":
                return DummyRes(500, {})
            if path == "/state":
                return DummyRes(200, {"device_id": "X", "valves": []})
            return DummyRes(404, {})

    monkeypatch.setattr(httpx, "AsyncClient", lambda *a, **k: FakeCli())

    dc = DeviceController("10.0.0.5")
    result = await dc.discover()
    assert result["ip"] == "10.0.0.5"
    assert "http://" not in result["ip"]

# -----------------------------
# 2) extract_json_from_response
# -----------------------------
def test_extract_json_happy_path():
    s = 'ignore { "a": 1, "b": 2 } trailing'
    out = extract_json_from_response(s)
    assert out == {"a": 1, "b": 2}

def test_extract_json_throws_on_no_json():
    with pytest.raises(HTTPException):
        extract_json_from_response("no JSON here")

# -----------------------------
# 3) dynamic USE_OLLAMA logic
# -----------------------------
def test_use_ollama_flag_respects_testing(monkeypatch):
    monkeypatch.setenv("USE_OLLAMA", "false")
    monkeypatch.setenv("TESTING", "1")
    import app.services.llm as llm
    importlib.reload(llm)
    assert llm.USE_OLLAMA is True

def test_use_ollama_flag_respects_env_when_not_testing(monkeypatch):
    monkeypatch.setenv("USE_OLLAMA", "true")
    monkeypatch.setenv("TESTING", "0")
    import app.services.llm as llm
    importlib.reload(llm)
    assert llm.USE_OLLAMA is True

# -----------------------------
# 4) call_llm_async openai path
# -----------------------------
@pytest.mark.asyncio
async def test_call_llm_async_openai():
    import app.services.llm as llm

    if llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=true – skipping OpenAI branch")
    if not os.getenv("OPENAI_API_KEY"):
        pytest.skip("OPENAI_API_KEY missing – skipping live OpenAI test")

    model = os.getenv("GPT_MODEL") or "gpt-3.5-turbo"
    parsed, raw = await call_llm_async("hi", model)
    assert isinstance(parsed, dict)
    assert raw.strip().startswith("{")

# -----------------------------
# 5) build_dosing_prompt errors
# -----------------------------
@pytest.mark.asyncio
async def test_build_dosing_prompt_raises_on_no_pumps():
    dummy = Device(
        id="d1",
        mac_id="m",
        name="n",
        type="dosing_unit",
        http_endpoint="e",
        pump_configurations=None,
        sensor_parameters={},
        valve_configurations=[],
        switch_configurations=[]
    )
    with pytest.raises(ValueError):
        await build_dosing_prompt(dummy, {"ph": 7, "tds": 100}, {})

# -----------------------------
# 6) parse_json_response edge
# -----------------------------
def test_parse_json_response_strips_extra_text():
    s = "junk { 'x': 10 } more junk"
    out = parse_json_response(s)
    assert out == {"x": 10}

@pytest.mark.asyncio
async def test_discover_both_endpoints_fail(monkeypatch):
    class DummyRes:
        def __init__(self, code): self.status_code = code
        def json(self): return {}
    class FakeCli:
        async def __aenter__(self): return self
        async def __aexit__(self, *a): pass
        async def get(self, path, *a, **k):
            return DummyRes(500)  # always fail
    monkeypatch.setattr(httpx, "AsyncClient", lambda *a, **k: FakeCli())

    dc = DeviceController("10.0.0.99")
    result = await dc.discover()
    assert result is None

def test_extract_json_multiple_json_blocks():
    s = 'prefix {"a":1} middle {"b":2} suffix'
    out = extract_json_from_response(s)
    assert out == {"a": 1}

# -----------------------------
# 7) call_llm_async ollama error propagation
# -----------------------------
@pytest.mark.asyncio
async def test_call_llm_async_ollama_http_error():
    import app.services.llm as llm
    if not llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=false – skipping Ollama branch")

    # An empty prompt should provoke a 400 from Ollama
    with pytest.raises(HTTPException):
        await call_llm_async("", llm.MODEL_1_5B)

# -----------------------------
# 8) parse_json_response top-level list
# -----------------------------
def test_parse_json_response_top_level_list():
    s = "[ {'x':10}, {'y':20} ] extra"
    out = parse_json_response(s)
    assert isinstance(out, list)
    assert out == [{"x": 10}, {"y": 20}]

# -----------------------------
# 9) build_dosing_prompt many pumps
# -----------------------------
@pytest.mark.asyncio
async def test_build_dosing_prompt_many_pumps():
    class D:
        def __init__(self):
            self.pump_configurations = [
                {"pump_number": i, "chemical_name": f"C{i}", "chemical_description": "D"}
                for i in range(1, 5)
            ]
            self.id = "X"
    dev = D()
    sensor = {"ph": 7, "tds": 100}
    profile = {
        "plant_name": "P", "plant_type": "T", "growth_stage": "G",
        "seeding_date": "2020", "region": "R", "location": "L",
        "target_ph_min": 5, "target_ph_max": 8,
        "target_tds_min": 50, "target_tds_max": 150,
        "dosing_schedule": {}
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    for i in range(1, 5):
        assert f"Pump {i}:" in prompt


----- tests/conftest.py -----
# tests/conftest.py
"""
Pytest fixtures for Hydroleaf

▪︎ Spins‑up a dedicated Postgres DB (TEST_DATABASE_URL) for the whole test run
▪︎ Overrides FastAPI’s DB dependency to use that same Session
▪︎ Truncates every table after each test
▪︎ Provides an httpx.AsyncClient + a deterministic DeviceController mock
▪︎ Logs the result of each test to test_logs.txt, including detailed failure reasons
"""

import os
import sys
import datetime as _dt
from pathlib import Path

import pytest
from httpx import AsyncClient
from sqlalchemy import create_engine, text
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

# ───────────────────────── paths / env ──────────────────────────
ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

# Force TESTING early
os.environ["TESTING"] = "1"
TEST_DB_URL = os.getenv(
    "TEST_DATABASE_URL",
    "postgresql+asyncpg://postgres@localhost:5432/deadpool",
)

# ───────────────────────── database setup ───────────────────────
from app.core.database import Base, AsyncSessionLocal  # the real one
from app.main import app
from app.core.database import get_db

# make a test‐only engine + sessionmaker
_test_engine = create_async_engine(TEST_DB_URL, echo=False, future=True)
TestSessionLocal = async_sessionmaker(
    _test_engine, class_=AsyncSession, expire_on_commit=False
)

# __CRITICAL__: point the app’s AsyncSessionLocal at our TestSessionLocal
import app.core.database as _db_mod
_db_mod.AsyncSessionLocal = TestSessionLocal

# also override the get_db dependency
@pytest.fixture(scope="session", autouse=True)
async def _setup_db_and_overrides():
    # create all tables once
    async with _test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    async def _override_get_db() -> AsyncSession:
        async with TestSessionLocal() as session:
            try:
                yield session
                await session.commit()
            except:
                await session.rollback()
                raise

    app.dependency_overrides[get_db] = _override_get_db

    # make admin routes always succeed
    try:
        from app.routers.admin_subscriptions import get_current_admin
        app.dependency_overrides[get_current_admin] = lambda: True
    except ImportError:
        pass

    yield
    # teardown handled by table‐truncation fixture below

# sync engine for truncation
_SYNC_DB_URL = TEST_DB_URL.replace(
    "postgresql+asyncpg://", "postgresql+psycopg2://"
)
_sync_engine = create_engine(_SYNC_DB_URL, future=True)

@pytest.fixture(autouse=True)
def _truncate_tables_after_each_test():
    yield
    # wipe everything
    with _sync_engine.begin() as conn:
        conn.execute(text("SET session_replication_role = replica;"))
        for tbl in reversed(Base.metadata.sorted_tables):
            conn.execute(text(f'TRUNCATE TABLE "{tbl.name}" RESTART IDENTITY CASCADE'))
        conn.execute(text("SET session_replication_role = DEFAULT;"))

# ─────────────────── Device‑controller mock ────────────────────
class MockController:
    def __init__(self, device_ip: str, request_timeout: float = 10.0):
        self.device_ip = device_ip

    async def discover(self):
        suffix_map = {
            "dosing":    {"device_id": "dev-dosing", "name": "Mock Dosing", "type": "dosing_unit"},
            "sensor":    {"device_id": "dev-sensor", "name": "Mock Sensor", "type": "ph_tds_sensor"},
            "valve":     {"device_id": "dev-valve",  "name": "Mock Valve",  "type": "valve_controller"},
            "switch":    {"device_id": "dev-switch", "name": "Mock Switch", "type": "smart_switch"},
        }
        for suf, payload in suffix_map.items():
            if self.device_ip.endswith(suf):
                return {**payload, "ip": self.device_ip}
        return None

@pytest.fixture(autouse=True)
def _patch_device_controller(monkeypatch, request):
    # only for endpoints that use async_client
    if "async_client" in request.fixturenames:
        import app.services.device_controller as dc_mod
        monkeypatch.setattr(dc_mod, "DeviceController", MockController)

# ─────────────────── camera data root helper ────────────────────
@pytest.fixture(autouse=True)
def _temp_cam_root(tmp_path, monkeypatch):
    monkeypatch.setenv("CAM_DATA_ROOT", str(tmp_path))
    from importlib import reload
    reload(__import__("app.core.config"))
    yield

# ───────────────────────── httpx AsyncClient ─────────────────────────
@pytest.fixture
async def async_client():
    async with AsyncClient(app=app, base_url="http://testserver") as client:
        yield client

# ─────────────────────── result‑logging plugin ────────────────────────
_LOG_PATH = ROOT / "test_logs.txt"

def pytest_sessionstart(session):
    with _LOG_PATH.open("w", encoding="utf-8") as fp:
        fp.write(f"Test run started: {_dt.datetime.utcnow().isoformat()}Z\n")
        fp.write("=" * 70 + "\n")

def pytest_runtest_logreport(report):
    if report.when != "call":
        return

    outcome = "PASSED" if report.passed else "FAILED" if report.failed else "SKIPPED"
    ts = _dt.datetime.utcnow().isoformat() + "Z"
    with _LOG_PATH.open("a", encoding="utf-8") as fp:
        fp.write(f"{ts} | {report.nodeid} | {outcome} | {report.duration:.2f}s\n")
        if report.failed:
            fp.write("--- Failure details below ---\n")
            longrepr = getattr(report, "longreprtext", None) or str(report.longrepr)
            fp.write(longrepr)
            if not longrepr.endswith("\n"):
                fp.write("\n")
            fp.write("-" * 70 + "\n")


----- tests/test_camera_tasks.py -----
# tests/test_camera_tasks.py
"""
Quick sanity-check that the camera_tasks pipeline

• moves raw → processed
• starts (or appends to) a clip writer
"""

import asyncio
from pathlib import Path

import cv2
import numpy as np
import pytest


# ─────────────────────────────────────────────────────────────────────────────
# Point CAM_DATA_ROOT at pytest’s tmp dir for every test in this module
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture(autouse=True)
def _temp_data_root(tmp_path, monkeypatch):
    monkeypatch.setenv("CAM_DATA_ROOT", str(tmp_path))
    # ensure any module-level constants are regenerated
    from importlib import reload
    reload(__import__("app.core.config"))
    yield


@pytest.mark.asyncio
async def test_encode_and_cleanup_creates_processed_and_clip(tmp_path, monkeypatch):
    cam_id = "cam_test"

    # Import after env var is set so camera_tasks sees the new CAM_DATA_ROOT.
    from app.utils import camera_tasks

    # Ask the library for the canonical folder layout ↓↓↓
    raw_dir, processed_dir, clips_dir = camera_tasks._ensure_dirs(cam_id)

    # ── make one dummy 320 × 240 JPEG in the *right* raw folder ──────────────
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    cv2.putText(img, "dummy", (50, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

    raw_path = raw_dir / "1.jpg"
    raw_dir.mkdir(parents=True, exist_ok=True)          # in case helper skipped it
    cv2.imwrite(str(raw_path), img)

    # Skip YOLO – make _annotate() a cheap no-op that returns zero detections
    monkeypatch.setattr(camera_tasks, "_annotate", lambda x: (x, []))

    # ── run the pipeline ────────────────────────────────────────────────────
    await camera_tasks.encode_and_cleanup(cam_id)

    # ── assertions ─────────────────────────────────────────────────────────
    # processed JPEG present
    proc_files = list(processed_dir.glob("*_processed.jpg"))
    assert len(proc_files) == 1, "processed frame was not written"

    # at least one .mp4 in the clip directory
    clip_files = list(clips_dir.glob("*.mp4"))
    assert clip_files, "video clip was not created"

    # raw frame should be gone
    assert not raw_path.exists(), "raw frame should have been deleted"


----- tests/test_payments_extended.py -----
# tests/test_payments_extended.py
import datetime
import pytest
from httpx import AsyncClient
from app.main import app
from app.models import PaymentStatus


# --------------------------------------------------------------------------- #
# Helpers                                                                     #
# --------------------------------------------------------------------------- #
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "admin@example.com"
    hashed_password = "x"


async def _always_admin():
    return _DummyAdmin


def _override_admin_dep():
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin


# --------------------------------------------------------------------------- #
# Fixtures                                                                     #
# --------------------------------------------------------------------------- #
@pytest.fixture
async def signed_up_user(async_client):
    """
    Quickly sign up a user and return (token, headers).
    """
    resp = await async_client.post(
        "/api/v1/auth/signup",
        json={"email": "pay@example.com", "password": "p", "name": "n", "location": "blr"},
    )
    token = resp.json()["access_token"]
    return token, {"Authorization": f"Bearer {token}"}


@pytest.fixture
async def basic_plan(async_client):
    _override_admin_dep()
    resp = await async_client.post(
        "/admin/plans/",
        json={
            "name": "30-day",
            "device_types": ["dosing_unit"],
            "duration_days": 30,
            "price_cents": 9999,
        },
        headers={"Authorization": "Bearer x"},
    )
    return resp.json()["id"]


@pytest.fixture
async def dosing_device(async_client, signed_up_user):
    _, hdrs = signed_up_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "FF:EE",
            "name": "Test Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://dosing",  # picked up by MockController
            "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
        },
        headers=hdrs,
    )
    return resp.json()["id"]


# --------------------------------------------------------------------------- #
# 1) Happy-path still works (sanity check)                                     #
# --------------------------------------------------------------------------- #
@pytest.mark.asyncio
async def test_payment_happy_path(async_client, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    token, hdrs = signed_up_user

    # create → upload proof → confirm
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": dosing_device, "plan_id": basic_plan}, headers=hdrs
        )
    ).json()
    assert order["status"] == PaymentStatus.PENDING

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"BIN", "image/jpeg")},
    )

    order = (
        await async_client.post(
            f'/api/v1/payments/confirm/{order["id"]}',
            json={"upi_transaction_id": "TXN-1"},
            headers=hdrs,
        )
    ).json()
    assert order["status"] == PaymentStatus.PROCESSING

    # admin approves
    order = (
        await async_client.post(
            f'/admin/payments/approve/{order["id"]}',
            headers={"Authorization": "Bearer x"},
        )
    ).json()
    assert order["status"] == PaymentStatus.COMPLETED


# --------------------------------------------------------------------------- #
# 2) Reject flow                                                               #
# --------------------------------------------------------------------------- #
@pytest.mark.asyncio
async def test_payment_reject_flow(async_client, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user

    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": dosing_device, "plan_id": basic_plan}, headers=hdrs
        )
    ).json()

    # upload proof but *do not* confirm yet
    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"BIN", "image/jpeg")},
    )

    # admin rejects directly from PENDING
    r = await async_client.post(
        f'/admin/payments/reject/{order["id"]}',
        headers={"Authorization": "Bearer x"},
    )
    assert r.status_code == 200
    assert r.json()["status"] == PaymentStatus.FAILED


# --------------------------------------------------------------------------- #
# 3) Confirm without proof                                                     #
# --------------------------------------------------------------------------- #
@pytest.mark.asyncio
async def test_confirm_without_screenshot_fails(async_client, signed_up_user, basic_plan, dosing_device):
    _, hdrs = signed_up_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": dosing_device, "plan_id": basic_plan}, headers=hdrs
        )
    ).json()

    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-1"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "upload" in r.json()["detail"].lower()


# --------------------------------------------------------------------------- #
# 4) Double confirm idempotency                                                #
# --------------------------------------------------------------------------- #
@pytest.mark.asyncio
async def test_double_confirm_is_noop(async_client, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": dosing_device, "plan_id": basic_plan}, headers=hdrs
        )
    ).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"BIN", "image/jpeg")},
    )

    # first confirm
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-X"},
        headers=hdrs,
    )

    # second confirm should error 400
    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-Y"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "current status" in r.json()["detail"].lower()


# --------------------------------------------------------------------------- #
# 5) Unauthorized approve must fail                                            #
# --------------------------------------------------------------------------- #
@pytest.mark.asyncio
async def test_admin_auth_required_for_approve(async_client, signed_up_user, basic_plan, dosing_device):
    token, hdrs = signed_up_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": dosing_device, "plan_id": basic_plan}, headers=hdrs
        )
    ).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"BIN", "image/jpeg")},
    )
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-Z"},
        headers=hdrs,
    )

    # no dependency override → real admin auth kicks in → expect 401/403
    r = await async_client.post(f'/admin/payments/approve/{order["id"]}')
    assert r.status_code in (401, 403)


----- tests/test_token_refactor.py -----
# tests/test_token_refactor.py

import secrets
import pytest
from app.models import Device, DeviceToken, DeviceType
from app.dependencies import verify_device_token
from httpx import AsyncClient
from app.main import app
from app.core.database import AsyncSessionLocal

@pytest.mark.asyncio
async def test_issue_and_verify_device_token():
    # use one transaction for both inserts
    async with AsyncSessionLocal() as db:
        async with db.begin():
            dev = Device(
                id="dev-1",
                mac_id="mac-1",
                name="Demo",
                type=DeviceType.DOSING_UNIT,
                http_endpoint="http://example",
                is_active=True,
            )
            db.add(dev)

            token = secrets.token_urlsafe(16)
            db.add(DeviceToken(
                device_id=dev.id,
                token=token,
                device_type=dev.type,
            ))
    # both rows are flushed & committed at this point

    # now verify against the token
    class DummyCred:
        credentials = token

    async with AsyncSessionLocal() as db_verify:
        device_id = await verify_device_token(
            DummyCred,
            db_verify,
            expected_type=DeviceType.DOSING_UNIT
        )
    assert device_id == "dev-1"


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint(monkeypatch):
    # stub admin auth dependency to always succeed
    monkeypatch.setattr(
        "app.routers.admin_subscriptions.get_current_admin",
        lambda: True
    )

    # insert a device in one transaction
    async with AsyncSessionLocal() as db:
        async with db.begin():
            db.add(Device(
                id="dev-2",
                mac_id="mac-2",
                name="Demo2",
                type=DeviceType.VALVE_CONTROLLER,
                http_endpoint="http://x",
                is_active=True,
            ))

    # now call the endpoint
    async with AsyncClient(app=app, base_url="http://test") as client:
        resp = await client.post("/admin/device/dev-2/issue-token")
    assert resp.status_code == 201
    data = resp.json()
    assert data["device_id"] == "dev-2"
    assert "token" in data


----- tests/test_plant_service.py -----
# tests/test_plant_service.py
import pytest
from fastapi import HTTPException
from app.services.plant_service import (
    get_all_plants,
    get_plant_by_id,
    create_plant,
    delete_plant,
)
from app.models import Plant

# --- helpers to fake the DB session and results ---
class DummyResult:
    def __init__(self, items):
        self._items = items
    def scalars(self):
        return self
    def all(self):
        return self._items

class FakeSession:
    def __init__(self, plants=None, single=None):
        self._plants = plants or []
        self._single = single
    async def execute(self, stmt):
        return DummyResult(self._plants)
    async def get(self, model, pk):
        return self._single
    async def add(self, obj): pass
    async def commit(self): pass
    async def refresh(self, obj): pass
    async def delete(self, obj): pass

@pytest.mark.asyncio
async def test_get_all_plants_empty():
    sess = FakeSession(plants=[])
    plants = await get_all_plants(sess)
    assert plants == []

@pytest.mark.asyncio
async def test_get_all_plants_nonempty():
    p1 = Plant(id=1, name="A", type="T", growth_stage="G", seeding_date="2020-01-01", region="R", location="L")
    p2 = Plant(id=2, name="B", type="T", growth_stage="G", seeding_date="2020-01-02", region="R", location="L")
    sess = FakeSession(plants=[p1, p2])
    plants = await get_all_plants(sess)
    assert plants == [p1, p2]

@pytest.mark.asyncio
async def test_get_plant_by_id_found():
    p = Plant(id=5, name="X", type="T", growth_stage="G", seeding_date="2020-01-03", region="R", location="L")
    sess = FakeSession(single=p)
    got = await get_plant_by_id(5, sess)
    assert got is p

@pytest.mark.asyncio
async def test_get_plant_by_id_not_found():
    sess = FakeSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await get_plant_by_id(123, sess)
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_create_and_delete_plant(tmp_path, monkeypatch):
    # For create_plant and delete_plant we actually need a DB, but we can at least
    # assert that they return the right types and messages under a fake session.
    class FakePS(FakeSession):
        async def commit(self): pass
        async def refresh(self, obj): pass
    fake = FakePS()
    # create_plant
    create_schema = type("S", (), {"model_dump": lambda self: {
        "name":"P","type":"T","growth_stage":"G","seeding_date":"2020-01-01","region":"R","location":"L"}})()
    new = await create_plant(create_schema, fake)
    assert isinstance(new, Plant)
    # delete_plant: if single is None -> 404
    fake2 = FakeSession(single=None)
    with pytest.raises(HTTPException):
        await delete_plant(1, fake2)
    # if present -> returns dict
    fake3 = FakeSession(single=new)
    out = await delete_plant(new.id, fake3)
    assert out == {"message": "Plant deleted successfully"}

@pytest.mark.asyncio
async def test_delete_plant_success(monkeypatch):
    """If the plant exists, delete_plant returns the success dict."""
    p = Plant(id=99, name="A", type="T", growth_stage="G",
              seeding_date="2020-01-01", region="R", location="L")
    sess = FakeSession(single=p)
    out = await delete_plant(99, sess)
    assert out == {"message":"Plant deleted successfully"}

@pytest.mark.asyncio
async def test_get_all_plants_db_error(monkeypatch):
    """If sess.execute raises, get_all_plants should return [] (per implementation)."""
    class BadSession(FakeSession):
        async def execute(self, stmt):
            raise RuntimeError("db is down")
    sess = BadSession()
    plants = await get_all_plants(sess)
    assert plants == []


----- tests/test_subscriptions_flow.py -----
# tests/test_subscriptions_flow.py
"""
End-to-end verification of the subscription life-cycle.

Scenarios
---------
1.  Happy-path:  SIGN-UP → PLAN → DEVICE → ORDER (PENDING → PROCESSING → COMPLETED)
2.  Guard-rails:
      a. confirm *without* screenshot  → 400
      b. double confirm                → 400
      c. unauthenticated admin approve → 401 / 403
3.  Reject flow: PENDING  → FAILED        (admin rejects)
4.  Expiry logic: already-expired order cannot be confirmed.
"""

from __future__ import annotations

import datetime as _dt
from typing import Tuple

import pytest
from httpx import AsyncClient

from app.main import app
from app.models import PaymentStatus


# ─────────────────────────────────────────────────────────────────────────────
# Helpers / overrides
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "root@example.com"
    hashed_password = "x"


async def _always_admin() -> _DummyAdmin:  # pragma: no cover
    return _DummyAdmin


def _override_admin_dep() -> None:
    """Force all admin-protected routes to succeed."""
    from app.dependencies import get_current_admin

    app.dependency_overrides[get_current_admin] = _always_admin


# ─────────────────────────────────────────────────────────────────────────────
# Fixture factories
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture
async def new_user(async_client: AsyncClient) -> Tuple[str, dict]:
    """Sign-up a user and return ``(token, headers)``."""
    resp = await async_client.post(
        "/api/v1/auth/signup",
        json={
            "email": "sub@test.io",
            "password": "pwd",
            "name": "grower",
            "location": "blr",
        },
    )
    token = resp.json()["access_token"]
    return token, {"Authorization": f"Bearer {token}"}


@pytest.fixture
async def plan(async_client: AsyncClient) -> str:
    """Create a 30-day dosing plan (admin)."""
    _override_admin_dep()
    resp = await async_client.post(
        "/admin/plans/",
        json={
            "name": "30-Day-Basic",
            "device_types": ["dosing_unit"],
            "duration_days": 30,
            "price_cents": 123_45,
        },
        headers={"Authorization": "Bearer any"},
    )
    return resp.json()["id"]


@pytest.fixture
async def device(async_client: AsyncClient, new_user: Tuple[str, dict]) -> str:
    """Register a mock dosing unit (discovered via MockController)."""
    _, hdrs = new_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "AA:BB",
            "name": "Mock Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://dosing",  # triggers tests.conftest.MockController
            "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
        },
        headers=hdrs,
    )
    return resp.json()["id"]


# ─────────────────────────────────────────────────────────────────────────────
# 1. Happy-path
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_subscription_happy_path(async_client: AsyncClient, new_user, plan, device):
    _override_admin_dep()
    _, hdrs = new_user

    # ── 1) create payment order ────────────────────────────────────────────
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()
    assert PaymentStatus(order["status"]) is PaymentStatus.PENDING
    assert order["qr_code_url"].endswith(".png")
    expires_at = _dt.datetime.fromisoformat(order["expires_at"].rstrip("Z"))
    assert expires_at > _dt.datetime.utcnow()  # in the future

    # ── 2) upload screenshot ───────────────────────────────────────────────
    up = await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"\xFF\xD8\xFF", "image/jpeg")},
    )
    assert up.status_code == 200
    assert up.json()["screenshot_path"].endswith(".jpg")

    # ── 3) confirm (→ PROCESSING) ───────────────────────────────────────────
    conf = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-001"},
        headers=hdrs,
    )
    assert PaymentStatus(conf.json()["status"]) is PaymentStatus.PROCESSING
    assert conf.json()["upi_transaction_id"] == "TXN-001"

    # ── 4) admin approve (→ COMPLETED) ──────────────────────────────────────
    done = await async_client.post(
        f'/admin/payments/approve/{order["id"]}', headers={"Authorization": "Bearer any"}
    )
    assert PaymentStatus(done.json()["status"]) is PaymentStatus.COMPLETED

    # ── 5) subscription visible & active ───────────────────────────────────
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert len(subs) == 1
    sub = subs[0]
    assert sub["device_id"] == device
    assert sub["active"] is True
    # dates sanity
    start = _dt.datetime.fromisoformat(sub["start_date"].rstrip("Z"))
    end = _dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    assert (end - start).days == 30


# ─────────────────────────────────────────────────────────────────────────────
# 2. Guard-rails
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_confirm_without_screenshot(async_client: AsyncClient, new_user, plan, device):
    _, hdrs = new_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()

    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "NO-PIC"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "upload" in r.json()["detail"].lower()


@pytest.mark.asyncio
async def test_double_confirm(async_client: AsyncClient, new_user, plan, device):
    _override_admin_dep()
    _, hdrs = new_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()
    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"IMG", "image/jpeg")},
    )
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "FIRST"},
        headers=hdrs,
    )
    second = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "SECOND"},
        headers=hdrs,
    )
    assert second.status_code == 400
    assert "current status" in second.json()["detail"].lower()


@pytest.mark.asyncio
async def test_admin_auth_required(async_client: AsyncClient, new_user, plan, device):
    _, hdrs = new_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()
    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"BIN", "image/jpeg")},
    )
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN"},
        headers=hdrs,
    )

    # no admin override here → expect 401 / 403
    unauth = await async_client.post(f'/admin/payments/approve/{order["id"]}')
    assert unauth.status_code in (401, 403)


# ─────────────────────────────────────────────────────────────────────────────
# 3. Reject flow (PENDING → FAILED)
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_reject_flow(async_client: AsyncClient, new_user, plan, device):
    _override_admin_dep()
    _, hdrs = new_user
    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()
    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"PIC", "image/jpeg")},
    )
    rej = await async_client.post(
        f'/admin/payments/reject/{order["id"]}', headers={"Authorization": "Bearer any"}
    )
    assert PaymentStatus(rej.json()["status"]) is PaymentStatus.FAILED


# ─────────────────────────────────────────────────────────────────────────────
# 4. Expiry logic
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_order_expired_cannot_confirm(async_client: AsyncClient, monkeypatch, new_user, plan, device):
    _override_admin_dep()
    _, hdrs = new_user

    # Patch datetime.utcnow **before** hitting /create so order gets past timestamp
    import app.routers.payments as pay_mod

    orig_utcnow = pay_mod.datetime.utcnow

    def _utc_past() -> _dt.datetime:
        return orig_utcnow() - _dt.timedelta(minutes=20)

    # monkeypatch the *method* on the datetime class
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(_utc_past))

    order = (
        await async_client.post(
            "/api/v1/payments/create", json={"device_id": device, "plan_id": plan}, headers=hdrs
        )
    ).json()

    # restore clock for the remainder of the flow
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(orig_utcnow))

    # proof uploaded so the only reason to fail is expiry
    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.jpg", b"IMG", "image/jpeg")},
    )

    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "LATE"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "expired" in r.json()["detail"].lower()


----- tests/test_llm_service.py -----
# tests/test_llm_service.py
"""
Integration-style tests for app.services.llm
-------------------------------------------

• If `USE_OLLAMA=true` (or TESTING=1) we exercise the Ollama code‐path.
  Set `OLLAMA_URL` to your running instance (default
  http://localhost:11434/api/generate).  Tests that require the server will be
  skipped automatically when it isn’t reachable.

• If `USE_OLLAMA=false` we exercise the OpenAI code-path.  You **must** have
  `OPENAI_API_KEY` (and optionally `GPT_MODEL`, defaults to
  ``gpt-3.5-turbo``) in your environment.  Tests that need the key are skipped
  when it isn’t present.

• Google Serper queries in ``build_plan_prompt`` run only when
  ``SERPER_API_KEY`` is set; otherwise that test is skipped.

The fast, fully local unit-tests (string manipulation etc.) always run.
"""
from __future__ import annotations

import asyncio
import json
import os
from typing import Any, Dict

import httpx
import pytest
from fastapi import HTTPException

import app.services.llm as llm
from app.services.llm import (
    build_dosing_prompt,
    build_plan_prompt,
    call_llm_async,
    direct_openai_call,
    direct_ollama_call,
    enhance_query,
    parse_json_response,
    parse_ollama_response,
    parse_openai_response,
    validate_llm_response,
)

# --------------------------------------------------------------------------- #
#  Helper utilities                                                            #
# --------------------------------------------------------------------------- #


async def _ollama_available() -> bool:
    """
    Quick health-check: GET /api/tags on the Ollama host.
    """
    base = llm.OLLAMA_URL.split("/api/")[0]
    try:
        async with httpx.AsyncClient(timeout=2) as client:
            r = await client.get(f"{base}/api/tags")
            return r.status_code == 200
    except Exception:
        return False


def _openai_key_present() -> bool:
    return bool(os.getenv("OPENAI_API_KEY"))


def _serper_key_present() -> bool:
    return bool(os.getenv("SERPER_API_KEY"))


# --------------------------------------------------------------------------- #
#  1.  Pure utility functions (no I/O)                                         #
# --------------------------------------------------------------------------- #


def test_enhance_query_adds_context() -> None:
    q = "Adjust dose"
    profile = {
        "plant_name": "Rose",
        "plant_type": "Flower",
        "growth_stage": "Veg",
        "seeding_date": "2020",
        "location": "Farm",
    }
    out = enhance_query(q, profile)
    assert "Please consider that the plant 'Rose'" in out


def test_enhance_query_no_duplicate_location() -> None:
    q = "dose in Farm"
    profile = {"location": "Farm"}
    out = enhance_query(q, profile)
    assert "Please consider that the plant" not in out


def test_parse_json_response_valid() -> None:
    s = "{ 'a': 1, 'b': 2 } trailing"
    res = parse_json_response(s)
    assert res == {"a": 1, "b": 2}


def test_parse_json_response_malformed() -> None:
    with pytest.raises(HTTPException):
        parse_json_response("no json here")


def test_parse_ollama_response_removes_think() -> None:
    raw = "<think>debug</think>{\"x\":1}"
    cleaned = parse_ollama_response(raw)
    assert cleaned == "{\"x\":1}"


def test_parse_openai_response_good() -> None:
    raw = "prefix {\"y\":2} suffix"
    out = parse_openai_response(raw)
    assert out == json.dumps({"y": 2})


def test_parse_openai_response_nested() -> None:
    raw = "foo {\"a\":{\"b\":2}} bar"
    out = parse_openai_response(raw)
    assert out == json.dumps({"a": {"b": 2}})


def test_parse_openai_response_bad() -> None:
    with pytest.raises(ValueError):
        parse_openai_response("no braces at all")


def test_validate_llm_response_good() -> None:
    payload: Dict[str, Any] = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": 10, "reasoning": "ok"}
        ]
    }
    validate_llm_response(payload)  # should not raise


def test_validate_llm_response_missing_actions() -> None:
    with pytest.raises(ValueError):
        validate_llm_response({})


def test_validate_llm_response_bad_dose() -> None:
    bad = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": -5, "reasoning": "oops"}
        ]
    }
    with pytest.raises(ValueError):
        validate_llm_response(bad)


# --------------------------------------------------------------------------- #
#  2.  Prompt builders                                                         #
# --------------------------------------------------------------------------- #


class _DummyDevice:
    def __init__(self) -> None:
        self.id = "d1"
        self.pump_configurations = [
            {
                "pump_number": 1,
                "chemical_name": "Chem-A",
                "chemical_description": "Desc",
            }
        ]


@pytest.mark.asyncio
async def test_build_dosing_prompt_contains_expected_sections() -> None:
    dev = _DummyDevice()
    sensor = {"ph": 6.5, "tds": 300}
    profile = {
        "plant_name": "P",
        "plant_type": "T",
        "growth_stage": "G",
        "seeding_date": "2020",
        "region": "R",
        "location": "L",
        "target_ph_min": 5,
        "target_ph_max": 7,
        "target_tds_min": 100,
        "target_tds_max": 500,
        "dosing_schedule": {},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert "Pump 1: Chem-A" in prompt
    assert "- pH: 6.5" in prompt


@pytest.mark.asyncio
async def test_build_dosing_prompt_raises_when_no_pumps() -> None:
    class NoPump:
        id = "x"
        pump_configurations = None

    with pytest.raises(ValueError):
        await build_dosing_prompt(NoPump(), {"ph": 7, "tds": 100}, {})


@pytest.mark.asyncio
async def test_build_plan_prompt_live_search() -> None:
    """
    Runs only when SERPER_API_KEY is set – otherwise skip.
    """
    if not _serper_key_present():
        pytest.skip("SERPER_API_KEY missing – skipping live Serper test")

    sensor_data = {"P": 1, "TDS": 2}
    profile = {
        "plant_name": "TestPlant",
        "plant_type": "Veggie",
        "growth_stage": "Seedling",
        "seeding_date": "2023-01-01",
        "region": "Europe",
        "location": "Berlin",
    }
    prompt = await build_plan_prompt(sensor_data, profile, "optimal growth")
    assert "Detailed Search Insights" in prompt


# --------------------------------------------------------------------------- #
#  3.  Ollama branch (real HTTP calls)                                         #
# --------------------------------------------------------------------------- #


@pytest.mark.asyncio
async def test_direct_ollama_call_roundtrip() -> None:
    if not llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=false – OpenAI branch active")

    if not await _ollama_available():
        pytest.skip("Ollama server not reachable")

    _prompt = "Return exactly this JSON: {\"foo\": 42}"
    try:
        result = await direct_ollama_call(_prompt, llm.MODEL_1_5B)
    except HTTPException as exc:
        pytest.skip(f"Ollama call failed: {exc.detail}")

    assert isinstance(result, dict)
    # make sure JSON was actually parsed
    assert result.get("foo", None) == 42


@pytest.mark.asyncio
async def test_call_llm_async_ollama_path() -> None:
    if not llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=false – OpenAI branch active")
    if not await _ollama_available():
        pytest.skip("Ollama server not reachable")

    parsed, raw = await call_llm_async("Return {\"x\":1}", llm.MODEL_1_5B)
    assert isinstance(parsed, dict)
    # verify the actual values round‑trip
    assert parsed.get("x", None) == 1
    # raw must be the exact JSON serialization of parsed
    assert raw.strip() == json.dumps(parsed, separators=(',',':'))


# --------------------------------------------------------------------------- #
#  4.  OpenAI branch (real HTTPS calls)                                        #
# --------------------------------------------------------------------------- #


@pytest.mark.asyncio
async def test_direct_openai_call_live() -> None:
    if llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=true – Ollama branch active")

    if not _openai_key_present():
        pytest.skip("OPENAI_API_KEY missing")

    model = os.getenv("GPT_MODEL") or "gpt-3.5-turbo"
    out = await direct_openai_call("Return JSON {\"bar\": 7}", model)
    data = json.loads(out)
    assert isinstance(data, dict)


@pytest.mark.asyncio
async def test_direct_openai_call_missing_key() -> None:
    """
    Validates that the helper raises when the key is absent.
    Executed only when the real key is *not* in the environment.
    """
    if _openai_key_present():
        pytest.skip("Key present – cannot test missing-key behaviour")

    with pytest.raises(ValueError):
        await direct_openai_call("{}", "gpt-3.5-turbo")


@pytest.mark.asyncio
async def test_call_llm_async_openai_path() -> None:
    if llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=true – Ollama branch active")
    if not _openai_key_present():
        pytest.skip("OPENAI_API_KEY missing")

    model = os.getenv("GPT_MODEL") or "gpt-3.5-turbo"
    parsed, _ = await call_llm_async("Return {\"baz\":123}", model)
    assert isinstance(parsed, dict)


----- tests/test_devices.py -----
# tests/test_device_controller.py
import pytest
import httpx
from app.services.device_controller import DeviceController, get_device_controller

# ----------------------------------------
# Helpers for mocking HTTPX AsyncClient
# ----------------------------------------
class DummyResponse:
    def __init__(self, status_code: int, json_data: dict):
        self.status_code = status_code
        self._json = json_data
    def json(self) -> dict:
        return self._json
    def raise_for_status(self):
        if self.status_code >= 400:
            raise httpx.HTTPStatusError(f"Status code {self.status_code}", request=None, response=self)

class FakeAsyncClient:
    def __init__(self, responses: dict[str, tuple[int, dict]]):
        # responses: path suffix -> (status_code, json_data)
        self._responses = responses
    async def __aenter__(self):
        return self
    async def __aexit__(self, exc_type, exc, tb):
        pass
    async def get(self, url: str, *args, **kwargs):
        for path, (code, data) in self._responses.items():
            if url.endswith(path):
                return DummyResponse(code, data)
        return DummyResponse(404, {})
    async def post(self, url: str, *args, json=None, **kwargs):
        for path, (code, data) in self._responses.items():
            if url.endswith(path):
                return DummyResponse(code, data)
        return DummyResponse(404, {})

# ----------------------------------------
# Global fixture: patch httpx.AsyncClient
# ----------------------------------------
@pytest.fixture(autouse=True)
def patch_async_client(monkeypatch):
    # Default mock behavior for all endpoints
    default_responses = {
        '/discovery': (200, {'device_id': 'dev123', 'type': 'dosing_unit', 'version': '1.2.3'}),
        '/version': (200, {'version': '2.0.0'}),
        '/monitor': (200, {'ph': 7.2, 'tds': 450.0}),
        '/pump': (200, {'message': 'pump executed'}),
        '/dose_monitor': (200, {'message': 'combined pump executed'}),
        '/pump_calibration': (200, {'message': 'dosing cancelled'}),
        '/state': (200, {'device_id': 'valve456', 'valves': [{'id': 1, 'state': 'on'}]}),
        '/toggle': (200, {'new_state': 'off'}),
    }
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(default_responses))

# ----------------------------------------
# Test cases for discovery
# ----------------------------------------
@pytest.mark.asyncio
async def test_discover_via_discovery_endpoint():
    """
    Ensure discover() returns primary discovery JSON when /discovery succeeds.
    """
    dc = get_device_controller('http://mock-device')
    data = await dc.discover()
    assert data['device_id'] == 'dev123'
    assert data['type'] == 'dosing_unit'
    assert data['version'] == '1.2.3'
    assert data['ip'] == 'http://mock-device'

@pytest.mark.asyncio
async def test_discover_fallback_to_state_on_discovery_failure(monkeypatch):
    """
    Simulate /discovery failure and verify fallback to /state for valve_controller.
    """
    # Patch AsyncClient with only /state
    responses = {'/discovery': (500, {}), '/state': (200, {'device_id': 'valve789', 'valves': [{'id': 2, 'state': 'off'}]})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('192.168.0.10')
    result = await dc.discover()
    assert result['device_id'] == 'valve789'
    assert result['type'] == 'valve_controller'
    assert isinstance(result['valves'], list)
    assert result['valves'][0]['id'] == 2
    assert result['ip'] == '192.168.0.10'

# ----------------------------------------
# Test cases for version endpoint
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_version_prefers_version_endpoint():
    """
    get_version() should return /version when available.
    """
    dc = get_device_controller('device-ip')
    version = await dc.get_version()
    assert version == '2.0.0'

@pytest.mark.asyncio
async def test_get_version_fallbacks_to_discover_on_error(monkeypatch):
    """
    If /version returns error, get_version() should fallback to discover().
    """
    responses = {'/version': (404, {}), '/discovery': (200, {'device_id': 'd1', 'version': '3.3.3'})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('devip')
    version = await dc.get_version()
    assert version == '3.3.3'

# ----------------------------------------
# Test cases for sensor readings
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_sensor_readings_success():
    """
    get_sensor_readings() should parse ph and tds correctly.
    """
    dc = get_device_controller('devip')
    readings = await dc.get_sensor_readings()
    assert isinstance(readings, dict)
    assert readings['ph'] == pytest.approx(7.2)
    assert readings['tds'] == pytest.approx(450.0)

@pytest.mark.asyncio
async def test_get_sensor_readings_http_error(monkeypatch):
    """
    get_sensor_readings() should raise HTTPException on non-200.
    """
    responses = {'/monitor': (500, {'error': 'fail'})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('devip')
    with pytest.raises(httpx.HTTPStatusError):
        await dc.get_sensor_readings()

# ----------------------------------------
# Test cases for dosing operations
# ----------------------------------------
@pytest.mark.asyncio
async def test_execute_dosing_single_and_combined():
    """
    execute_dosing() should call /pump and /dose_monitor based on flag.
    """
    dc = get_device_controller('devip')
    single = await dc.execute_dosing(1, 100)
    assert single['message'] == 'pump executed'
    combined = await dc.execute_dosing(2, 50, combined=True)
    assert combined['message'] == 'combined pump executed'

@pytest.mark.asyncio
async def test_cancel_dosing_command():
    """
    cancel_dosing() should post to /pump_calibration with stop command.
    """
    dc = get_device_controller('devip')
    res = await dc.cancel_dosing()
    assert res['message'] == 'dosing cancelled'

# ----------------------------------------
# Test cases for valve state and toggle
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_state_success():
    """
    get_state() should fetch full valve state JSON.
    """
    dc = get_device_controller('devip')
    state = await dc.get_state()
    assert state['device_id'] == 'valve456'
    assert isinstance(state['valves'], list)
    assert state['valves'][0]['state'] == 'on'

@pytest.mark.asyncio
async def test_toggle_valve_success():
    """
    toggle_valve() should post to /toggle and return new_state.
    """
    dc = get_device_controller('devip')
    result = await dc.toggle_valve(1)
    assert 'new_state' in result
    assert result['new_state'] == 'off'

# ----------------------------------------
# Test invalid inputs
# ----------------------------------------
@pytest.mark.asyncio
async def test_toggle_valve_invalid_channel(monkeypatch):
    """
    toggle_valve() should raise ValueError if channel not in 1-4.
    """
    dc = get_device_controller('devip')
    with pytest.raises(ValueError):
        # channel 0 is invalid
        await dc.toggle_valve(0)

@pytest.mark.asyncio
async def test_get_version_both_fail(monkeypatch):
    """If both /version and /discovery fail, get_version returns None."""
    class DR:
        def __init__(self, code): self.status_code=code
        def json(self): return {}
    class FC:
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def get(self, path, *a,**k):
            return DR(500)  # always error
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *a,**k: FC())
    dc = DeviceController("10.1.1.1")
    v = await dc.get_version()
    assert v is None

@pytest.mark.asyncio
async def test_execute_dosing_http_error(monkeypatch):
    """If the /pump endpoint returns 500, execute_dosing raises HTTPStatusError."""
    # arrange FakeAsyncClient whose /pump returns 500
    from app.services.device_controller import DeviceController
    class FR:
        def __init__(self,*a,**k): pass
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def post(self, url, *a, json=None, **k):
            return DummyResponse(500, {})
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *a,**k: FR())
    dc = DeviceController("ip")
    with pytest.raises(httpx.HTTPStatusError):
        await dc.execute_dosing(1,100)

@pytest.mark.asyncio
async def test_toggle_valve_http_error(monkeypatch):
    """If /toggle returns 500, toggle_valve raises HTTPStatusError."""
    class FR:
        def __init__(self,*a,**k): pass
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def post(self, url, *a, json=None, **k):
            return DummyResponse(500,{})
    from app.services.device_controller import DeviceController
    monkeypatch.setattr(httpx,'AsyncClient',lambda *a,**k: FR())
    dc = DeviceController("ip")
    with pytest.raises(httpx.HTTPStatusError):
        await dc.toggle_valve(2)



----- tests/test_dose_manager.py -----
# tests/test_dose_manager.py
import pytest
from fastapi import HTTPException
from app.services.dose_manager import DoseManager

class DummyController:
    def __init__(self, *args, **kw): pass
    async def execute_dosing(self, pump, amount, combined=False):
        return {"ok": True, "pump": pump, "amount": amount, "combined": combined}
    async def cancel_dosing(self):
        return {"cancelled": True}

@pytest.fixture(autouse=True)
def patch_controller(monkeypatch):
    # replace DeviceController inside DoseManager with our dummy
    monkeypatch.setattr("app.services.dose_manager.DeviceController", lambda *a, **k: DummyController())

dm = DoseManager()

@pytest.mark.asyncio
async def test_execute_dosing_empty_actions():
    with pytest.raises(ValueError):
        await dm.execute_dosing("dev1", "http://x", [], combined=False)

@pytest.mark.asyncio
async def test_execute_dosing_missing_fields():
    # action missing pump or dose
    with pytest.raises(ValueError):
        await dm.execute_dosing("dev1", "http://x", [{"foo":1}], combined=True)

@pytest.mark.asyncio
async def test_execute_dosing_success_single_and_combined():
    actions = [{"pump_number": 2, "dose_ml": 25}]
    res = await dm.execute_dosing("dev1", "http://x", actions, combined=False)
    assert res["status"] == "command_sent"
    assert res["device_id"] == "dev1"
    assert res["actions"] == actions
    # combined
    res2 = await dm.execute_dosing("dev1", "http://x", actions, combined=True)
    assert res2["status"] == "command_sent"
    assert res2["actions"] == actions

@pytest.mark.asyncio
async def test_cancel_dosing_success():
    res = await dm.cancel_dosing("dev1", "http://x")
    assert res["status"] == "dosing_cancelled"
    assert res["device_id"] == "dev1"
    assert res["response"] == {"cancelled": True}

@pytest.mark.asyncio
async def test_cancel_dosing_success():
    res = await dm.cancel_dosing("devX","http://x")
    assert res == {"status":"dosing_cancelled","device_id":"devX","response":{"cancelled":True}}


