======= Directory: tests =======

----- tests/test_disease_detection_service.py -----
# tests/test_disease_detection_service.py
import os
import pytest
import httpx
from fastapi import HTTPException
from app.services.disease_detection_service import detect_disease_from_image


@pytest.mark.asyncio
@pytest.mark.xfail(reason="Will pass once backend uses PlantVillage model", strict=False)
async def test_detect_disease_real_tomato_image_returns_expected_label():
    """
    Integration-style test:
      - downloads a *real* plant image (URL can be overridden)
      - passes real-ish plant metadata (what we store in DB)
      - expects the model to return the correct PlantVillage disease label
    """
    url = os.getenv(
        "PLANT_TEST_IMAGE_URL",
        # Default: tomato bacterial spot photo on Wikipedia; override to PlantVillage sample in your env
        "https://upload.wikimedia.org/wikipedia/commons/3/3f/Bacterial_spot_of_tomato_BC1.JPG",
    )
    expected = os.getenv("PLANT_TEST_EXPECTED_LABEL", "Tomato___Bacterial_spot")

    # mirror the Plant table fields we store
    meta = {
        "name": "Tomato – test leaf",
        "type": "fruit",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Greenhouse",
        "location_description": "Rack 1",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700,
        # also include a simple hint for the model
        "plant": "tomato",
    }

    # fetch image bytes (skip if network blocked/unavailable)
    try:
        async with httpx.AsyncClient(timeout=10) as client:
            r = await client.get(url)
            if r.status_code != 200 or not r.content:
                pytest.skip(f"Could not fetch test image: HTTP {r.status_code}")
            img_bytes = r.content
    except httpx.RequestError:
        pytest.skip("Network required to fetch real plant image")

    out = await detect_disease_from_image(img_bytes, meta)

    # Once your backend calls PlantVillage, this xfail should flip to pass.
    assert isinstance(out, dict), out
    assert out["disease"] == expected
    assert 0.0 <= out.get("confidence", 0.0) <= 1.0


@pytest.mark.asyncio
async def test_detect_disease_invalid_image_raises():
    with pytest.raises(HTTPException):
        await detect_disease_from_image(b"not-an-image", {"plant": "tomato"})


@pytest.mark.asyncio
async def test_detect_disease_garbage_jpeg_header_raises():
    # truncated/invalid JPEG bytes → should be rejected by your image loader
    bad_jpeg = b"\xff\xd8\xff" + b"\x00" * 32
    with pytest.raises(HTTPException):
        await detect_disease_from_image(bad_jpeg, {"plant": "tomato"})


----- tests/conftest.py -----
# tests/conftest.py
import os
import sys
import datetime as _dt
from pathlib import Path
from dotenv import load_dotenv
import tests.virtual_iot as _virtual_iot

# 1) Load .env from project root, then force TESTING
ROOT = Path(__file__).resolve().parents[1]
load_dotenv(ROOT / ".env", override=False)
os.environ["TESTING"] = "1"
os.environ.setdefault("CAM_SKIP_ANNOTATE", "1")
os.environ.setdefault("CAM_DATA_ROOT", str(ROOT / ".camdata_test"))
(ROOT / ".camdata_test").mkdir(exist_ok=True, parents=True)
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import create_engine, text
from sqlalchemy.pool import NullPool
from sqlalchemy.engine.url import make_url
import jwt as _jwt
import uuid

# ─────────────────────────────────────────────────────────────────────────────
# Patch out JWT signature checks in tests
# ─────────────────────────────────────────────────────────────────────────────
_orig_jwt_decode = _jwt.decode
def _decode_no_key(token, key=None, algorithms=None, options=None, **kwargs):
    return _orig_jwt_decode(
        token,
        key or "",
        algorithms=algorithms,
        options={**(options or {}), "verify_signature": False},
        **kwargs,
    )
_jwt.decode = _decode_no_key

# Import config so TESTING=True picks up TEST_DATABASE_URL
import app.core.config  # noqa: F401

# Grab the test‐DB URL
TEST_DB_URL = os.getenv(
    "TEST_DATABASE_URL",
    "postgresql+asyncpg://postgres:1234@localhost:5432/hydroleaf_test",
)

# Build a *sync* URL for psycopg2 work (alembic, DDL, truncation)
_sync_url = make_url(TEST_DB_URL)
if "+asyncpg" in _sync_url.drivername:
    _sync_url = _sync_url.set(drivername="postgresql+psycopg2")
SYNC_DB_URL = str(_sync_url)

# ─────────────────────────────────────────────────────────────────────────────
# Fresh DB each test run: DROP DATABASE …; CREATE DATABASE …; apply schema
# Prefer Alembic if available; otherwise fallback to Base.metadata.create_all.
# ─────────────────────────────────────────────────────────────────────────────
def _recreate_database(sync_url: str) -> None:
    url = make_url(sync_url)
    dbname = url.database
    # connect to 'postgres' maintenance DB with same creds
    admin_url = url.set(database="postgres")
    admin_engine = create_engine(
        str(admin_url),
        future=True,
        poolclass=NullPool,
        isolation_level="AUTOCOMMIT",  # needed for DROP/CREATE DATABASE
    )
    with admin_engine.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
        # terminate existing connections (works without superuser in >=PG9.2 if you own the DB)
        conn.execute(
            text(
                """
                SELECT pg_terminate_backend(pid)
                FROM pg_stat_activity
                WHERE datname = :d AND pid <> pg_backend_pid()
                """
            ),
            {"d": dbname},
        )
        # drop & create (must be autocommit)
        conn.exec_driver_sql(f'DROP DATABASE IF EXISTS "{dbname}"')
        conn.exec_driver_sql(f'CREATE DATABASE "{dbname}" ENCODING \'UTF8\' TEMPLATE template1')
    admin_engine.dispose()

def _apply_schema_with_alembic_or_metadata(sync_url: str) -> None:
    # Try Alembic first (use local alembic.ini if present)
    ini = ROOT / "alembic.ini"
    if ini.exists():
        try:
            from alembic import command
            from alembic.config import Config
            cfg = Config(str(ini))
            # Force alembic to use the test DB URL
            cfg.set_main_option("sqlalchemy.url", sync_url)
            # Quiet alembic logger noise in CI
            cfg.attributes["configure_logger"] = False
            command.upgrade(cfg, "head")
            return
        except Exception as e:  # fall back to metadata if alembic hiccups
            print(f"[conftest] Alembic upgrade failed ({e}); falling back to metadata.create_all()")
    # Fallback: create all tables from models
    from app.core.database import Base
    eng = create_engine(sync_url, future=True, poolclass=NullPool)
    with eng.begin() as conn:
        Base.metadata.create_all(bind=conn)
    eng.dispose()

# Recreate DB & apply schema *before* any test engine connects
_recreate_database(SYNC_DB_URL)
_apply_schema_with_alembic_or_metadata(SYNC_DB_URL)

# ─────────────────────────────────────────────────────────────────────────────
# Async engine + sessionmaker for tests (no pooling)
# ─────────────────────────────────────────────────────────────────────────────
_test_engine = create_async_engine(TEST_DB_URL, echo=False, future=True, poolclass=NullPool)
TestSessionLocal = async_sessionmaker(_test_engine, class_=AsyncSession, expire_on_commit=False)

# Override the app’s AsyncSessionLocal
import app.core.database as _db_mod
_db_mod.AsyncSessionLocal = TestSessionLocal

# Import application and dependency
from app.main import app
from app.core.database import Base, get_db

def pytest_configure(config):
    """
    If pytest-cov is available, enable coverage of the 'app' package
    and show missing lines in the terminal report by default.
    """
    cov = config.pluginmanager.getplugin("cov")
    if cov:
        config.option.cov_source = ["app"]
        config.option.cov_report = ["term-missing"]

@pytest.fixture(scope="session", autouse=True)
async def _setup_db_and_overrides():
    # (Schema already applied above.) Still ensure metadata exists in case of fallback.
    async with _test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # Dependency override for get_db
    async def _override_get_db() -> AsyncSession:
        async with TestSessionLocal() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise

    app.dependency_overrides[get_db] = _override_get_db

    # Make all admin routes succeed in builds that import the generic dependency
    try:
        # Use the canonical dependency module so test overrides match other tests
        from app.dependencies import get_current_admin
        app.dependency_overrides[get_current_admin] = lambda: True
    except Exception:
        pass

    yield
    # Engines are disposed below

# Create a synchronous engine for table truncation (created AFTER schema)
_sync_engine = create_engine(SYNC_DB_URL, future=True, poolclass=NullPool)

@pytest.fixture(autouse=True)
def _truncate_tables_after_each_test():
    yield
    # Truncate all tables to reset state (no superuser assumptions)
    with _sync_engine.begin() as conn:
        for tbl in reversed(Base.metadata.sorted_tables):
            # Schema-qualified name if present
            fullname = f'{tbl.schema}."{tbl.name}"' if tbl.schema else f'"{tbl.name}"'
            conn.execute(text(f"TRUNCATE TABLE {fullname} RESTART IDENTITY CASCADE"))

@pytest.fixture(scope="session", autouse=True)
def _dispose_engines_at_end():
    # Dispose engines when the entire session ends
    yield
    try:
        _sync_engine.dispose()
    finally:
        try:
            _test_engine.sync_engine.dispose()
        except Exception:
            pass

# ───── Sign-up helper used by many tests ─────
@pytest.fixture
async def signed_up_user(async_client):
    """
    Returns (user_id, user_payload, auth_headers).
    The tests only use the headers, but we keep the shape as a triple.
    """
    email = f"test_{uuid.uuid4().hex[:12]}@example.com"
    payload = {
        "email": email,
        "password": "Pass!234",
        "first_name": "Test",
        "last_name": "User",
        "phone": "9999999999",
        "address": "1 St",
        "city": "Bengaluru",
        "state": "KA",
        "country": "IN",
        "postal_code": "560001",
    }
    r = await async_client.post("/api/v1/auth/signup", json=payload)
    assert r.status_code == 201, f"Signup failed: {r.status_code} {r.text}"
    data = r.json()

    # tolerate slightly different response shapes
    token = data.get("access_token") or data.get("token") or data.get("accessToken")
    assert token, f"Signup response missing token: {data}"
    headers = {"Authorization": f"Bearer {token}"}

    user_obj = data.get("user") or {}
    user_id = user_obj.get("id") or data.get("user_id")
    return user_id, user_obj, headers

# ───── Virtual IoT services ─────
@pytest.fixture(scope="session", autouse=True)
def virtual_iot_services():
    # start four FastAPI-based device emulators on localhost:8001–8004
    _virtual_iot.start_virtual_iot()
    yield
    _virtual_iot.stop_virtual_iot()

# ───── Async HTTP client ─────
@pytest.fixture
async def async_client():
    async with AsyncClient(app=app, base_url="http://testserver") as client:
        yield client

# ───── Test‐result logging ─────
_LOG_PATH = ROOT / "test_logs.txt"

def pytest_sessionstart(session):
    with _LOG_PATH.open("w", encoding="utf-8") as fp:
        fp.write(f"Test run started: {_dt.datetime.utcnow().isoformat()}Z\n")
        fp.write("=" * 70 + "\n")

def pytest_runtest_logreport(report):
    if report.when != "call":
        return
    outcome = "PASSED" if report.passed else "FAILED" if report.failed else "SKIPPED"
    ts = _dt.datetime.utcnow().isoformat() + "Z"
    with _LOG_PATH.open("a", encoding="utf-8") as fp:
        fp.write(f"{ts} | {report.nodeid} | {outcome} | {getattr(report,'duration',0):.2f}s\n")
        if report.failed:
            fp.write("--- Failure details below ---\n")
            longrepr = getattr(report, "longreprtext", None) or str(report.longrepr)
            fp.write(f"{longrepr}\n")
            if cap := getattr(report, "capstderr", None):
                fp.write(f"--- stderr ---\n{cap}\n")
            fp.write("-" * 70 + "\n")


----- tests/test_plant_endpoints.py -----
# tests/test_plant_endpoints.py
import pytest
from httpx import AsyncClient
import uuid
def _plant_payload(**overrides):
    base = {
        "name": "Lettuce",
        "type": "leaf",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Greenhouse",
        "location_description": "Rack 1",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700,
        "location_latitude": 12.3456,
        "location_longitude": 65.4321,
    }
    base.update(overrides)
    return base

@pytest.fixture
async def farm_and_headers(async_client: AsyncClient, signed_up_user):
    _, _, hdrs = signed_up_user
    farm = (await async_client.post(
        "/api/v1/farms/",
        json={"name": "F", "address": "A", "latitude": 0, "longitude": 0},
        headers=hdrs
    )).json()
    return farm["id"], hdrs

@pytest.fixture
async def another_user_headers(async_client: AsyncClient):
    payload = {
        "email": "otheruser@example.com",
        "password": "Pass!234",
        "first_name": "Other",
        "last_name": "User",
        "phone": "1234567890",
        "address": "1 St",
        "city": "C",
        "state": "S",
        "country": "IN",
        "postal_code": "000000",
    }
    r = await async_client.post("/api/v1/auth/signup", json=payload)
    assert r.status_code == 201
    token = r.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

# ─────────────────────────────────────────────────────
# Happy path & isolation
# ─────────────────────────────────────────────────────

@pytest.mark.asyncio
async def test_list_plants_empty_for_new_farm(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    uuid.UUID(str(farm_id))  # ensure farm_id is UUID
    resp = await async_client.get(f"/api/v1/farms/{farm_id}/plants/", headers=hdrs)
    assert resp.status_code == 200
    assert resp.json() == []

@pytest.mark.asyncio
async def test_create_get_list_delete_roundtrip(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    create = await async_client.post(
        f"/api/v1/farms/{farm_id}/plants/",
        json=_plant_payload(),
        headers=hdrs,
    )
    assert create.status_code == 201
    plant = create.json()
    pid = plant["id"]
    uuid.UUID(str(pid)) 
    # list contains it
    lst = await async_client.get(f"/api/v1/farms/{farm_id}/plants/", headers=hdrs)
    assert any(p["id"] == pid for p in lst.json())

    # get detail
    one = await async_client.get(f"/api/v1/farms/{farm_id}/plants/{pid}", headers=hdrs)
    assert one.status_code == 200
    detail = one.json()
    assert detail["id"] == pid
    # NEW: persisted geo matches input (approx)
    assert detail.get("location_latitude") == pytest.approx(12.3456)
    assert detail.get("location_longitude") == pytest.approx(65.4321)

    # delete
    dele = await async_client.delete(f"/api/v1/farms/{farm_id}/plants/{pid}", headers=hdrs)
    assert dele.status_code == 204

    # now 404 on get
    missing = await async_client.get(f"/api/v1/farms/{farm_id}/plants/{pid}", headers=hdrs)
    assert missing.status_code == 404

@pytest.mark.asyncio
async def test_multiple_plants_and_isolation_per_farm(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    farm2 = (await async_client.post(
        "/api/v1/farms/",
        json={"name": "F2", "address": "B", "latitude": 1, "longitude": 1},
        headers=hdrs,
    )).json()["id"]

    p1 = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(name="A"), headers=hdrs)).json()
    p2 = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(name="B"), headers=hdrs)).json()
    p3 = (await async_client.post(f"/api/v1/farms/{farm2}/plants/", json=_plant_payload(name="C"), headers=hdrs)).json()

    ids1 = {p["id"] for p in (await async_client.get(f"/api/v1/farms/{farm_id}/plants/", headers=hdrs)).json()}
    ids2 = {p["id"] for p in (await async_client.get(f"/api/v1/farms/{farm2}/plants/", headers=hdrs)).json()}
    assert ids1 == {p1["id"], p2["id"]}
    assert ids2 == {p3["id"]}

# ─────────────────────────────────────────────────────
# Not-found / wrong farm (only if you keep nested routes)
# ─────────────────────────────────────────────────────

@pytest.mark.asyncio
async def test_create_plant_in_nonexistent_farm_returns_404(async_client: AsyncClient, farm_and_headers):
    _, hdrs = farm_and_headers
    resp = await async_client.post(f"/api/v1/farms/{uuid.uuid4()}/plants/", json=_plant_payload(), headers=hdrs)
    assert resp.status_code == 404

@pytest.mark.asyncio
async def test_get_plant_from_wrong_farm_404(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    farm2 = (await async_client.post("/api/v1/farms/", json={"name": "F2", "address": "B", "latitude": 1, "longitude": 1}, headers=hdrs)).json()["id"]
    plant = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(), headers=hdrs)).json()
    r = await async_client.get(f"/api/v1/farms/{farm2}/plants/{plant['id']}", headers=hdrs)
    assert r.status_code == 404

@pytest.mark.asyncio
async def test_delete_plant_from_wrong_farm_404(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    farm2 = (await async_client.post("/api/v1/farms/", json={"name": "F2", "address": "B", "latitude": 1, "longitude": 1}, headers=hdrs)).json()["id"]
    plant = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(), headers=hdrs)).json()
    r = await async_client.delete(f"/api/v1/farms/{farm2}/plants/{plant['id']}", headers=hdrs)
    assert r.status_code == 404

@pytest.mark.asyncio
async def test_get_unknown_plant_404(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    r = await async_client.get(f"/api/v1/farms/{farm_id}/plants/{uuid.uuid4()}", headers=hdrs)
    assert r.status_code == 404

# ─────────────────────────────────────────────────────
# Auth guardrails
# ─────────────────────────────────────────────────────

@pytest.mark.asyncio
async def test_unauthenticated_requests_are_rejected(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    # create requires auth
    r1 = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload())
    assert r1.status_code == 401
    # list requires auth
    r2 = await async_client.get(f"/api/v1/farms/{farm_id}/plants/")
    assert r2.status_code == 401
    # make a plant (with auth) to test detail/delete unauthenticated
    plant_id = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(name="Auth OK"), headers=hdrs)).json()["id"]
    r3 = await async_client.get(f"/api/v1/farms/{farm_id}/plants/{plant_id}")
    r4 = await async_client.delete(f"/api/v1/farms/{farm_id}/plants/{plant_id}")
    assert r3.status_code == 401
    assert r4.status_code == 401

@pytest.mark.asyncio
async def test_other_user_cannot_access_my_farm_plants(async_client: AsyncClient, farm_and_headers, another_user_headers):
    farm_id, hdrs_owner = farm_and_headers
    plant_id = (await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=_plant_payload(name="Private"), headers=hdrs_owner)).json()["id"]

    # No-leak policy: pretend it does not exist for others -> 404 everywhere
    r_list = await async_client.get(f"/api/v1/farms/{farm_id}/plants/", headers=another_user_headers)
    r_get  = await async_client.get(f"/api/v1/farms/{farm_id}/plants/{plant_id}", headers=another_user_headers)
    r_del  = await async_client.delete(f"/api/v1/farms/{farm_id}/plants/{plant_id}", headers=another_user_headers)
    assert r_list.status_code == 404
    assert r_get.status_code  == 404
    assert r_del.status_code  == 404

# ─────────────────────────────────────────────────────
# Validation (deterministic; no “201 or 422”)
# ─────────────────────────────────────────────────────

@pytest.mark.asyncio
@pytest.mark.parametrize("missing_key", [
    "name", "type", "growth_stage", "seeding_date",
    "region", "location_description",
    "target_ph_min", "target_ph_max",
    "target_tds_min", "target_tds_max",
])
async def test_create_plant_missing_required_field_422(async_client: AsyncClient, farm_and_headers, missing_key):
    farm_id, hdrs = farm_and_headers
    payload = _plant_payload()
    payload.pop(missing_key)
    r = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=payload, headers=hdrs)
    assert r.status_code == 422

@pytest.mark.asyncio
async def test_create_plant_invalid_iso_datetime_422(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    bad = _plant_payload(seeding_date="07/01/2025 00:00")  # not ISO8601
    r = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad, headers=hdrs)
    assert r.status_code == 422

@pytest.mark.asyncio
async def test_create_plant_invalid_ph_range_422(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    # pH must be within 0..14
    bad_low  = _plant_payload(target_ph_min=-0.1)
    bad_high = _plant_payload(target_ph_max=14.5)
    r1 = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad_low, headers=hdrs)
    r2 = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad_high, headers=hdrs)
    assert r1.status_code == 422
    assert r2.status_code == 422

@pytest.mark.asyncio
async def test_create_plant_min_gt_max_422(async_client: AsyncClient, farm_and_headers):
    farm_id, hdrs = farm_and_headers
    # pH min > max
    bad_ph = _plant_payload(target_ph_min=7.0, target_ph_max=6.0)
    # TDS min > max
    bad_tds = _plant_payload(target_tds_min=800, target_tds_max=700)
    r1 = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad_ph, headers=hdrs)
    r2 = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad_tds, headers=hdrs)
    assert r1.status_code == 422
    assert r2.status_code == 422

@pytest.mark.asyncio
@pytest.mark.parametrize("lat,lon", [
    (-91, 0), (91, 0), (0, -181), (0, 181),
])
async def test_create_plant_invalid_latlon_range_422(async_client: AsyncClient, farm_and_headers, lat, lon):
    farm_id, hdrs = farm_and_headers
    bad = _plant_payload(location_latitude=lat, location_longitude=lon)
    r = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=bad, headers=hdrs)
    assert r.status_code == 422

@pytest.mark.asyncio
@pytest.mark.parametrize("field,bad_value", [
    # existing numeric type checks…
    ("target_ph_min", "low"),
    ("target_ph_max", "high"),
    ("target_tds_min", "a"),
    ("target_tds_max", "b"),
    ("target_ph_min", None),
    ("target_tds_min", None),
    # NEW: lat/lon must be numeric if provided
    ("location_latitude", "north"),
    ("location_longitude", "east"),
])
async def test_create_plant_numeric_fields_wrong_type_422(async_client: AsyncClient, farm_and_headers, field, bad_value):
    farm_id, hdrs = farm_and_headers
    payload = _plant_payload(**{field: bad_value})
    r = await async_client.post(f"/api/v1/farms/{farm_id}/plants/", json=payload, headers=hdrs)
    assert r.status_code == 422

----- tests/test_camera_tasks.py -----
# tests/test_camera_tasks.py
"""
Quick sanity-check that the camera_tasks pipeline

• moves raw → processed
• starts (or appends to) a clip writer
"""

import asyncio
from pathlib import Path

import cv2
import numpy as np
import pytest


# ─────────────────────────────────────────────────────────────────────────────
# Point CAM_DATA_ROOT at pytest’s tmp dir for every test in this module
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture(autouse=True)
def _temp_data_root(tmp_path, monkeypatch):
    monkeypatch.setenv("CAM_DATA_ROOT", str(tmp_path))
    # ensure any module-level constants are regenerated
    from importlib import reload
    reload(__import__("app.core.config"))
    yield


@pytest.mark.asyncio
async def test_encode_and_cleanup_creates_processed_and_clip(tmp_path, monkeypatch):
    cam_id = "cam_test"

    # Import after env var is set so camera_tasks sees the new CAM_DATA_ROOT.
    from app.utils import camera_tasks

    # Ask the library for the canonical folder layout ↓↓↓
    raw_dir, processed_dir, clips_dir = camera_tasks._ensure_dirs(cam_id)

    # ── make one dummy 320 × 240 JPEG in the *right* raw folder ──────────────
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    cv2.putText(img, "dummy", (50, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

    raw_path = raw_dir / "1.jpg"
    raw_dir.mkdir(parents=True, exist_ok=True)          # in case helper skipped it
    cv2.imwrite(str(raw_path), img)

    # Skip YOLO – make _annotate() a cheap no-op that returns zero detections
    monkeypatch.setattr(camera_tasks, "_annotate", lambda x: (x, []))

    # ── run the pipeline ────────────────────────────────────────────────────
    await camera_tasks.encode_and_cleanup(cam_id)

    # ── assertions ─────────────────────────────────────────────────────────
    # processed JPEG present
    proc_files = list(processed_dir.glob("*_processed.jpg"))
    assert len(proc_files) == 1, "processed frame was not written"

    # at least one .mp4 in the clip directory
    clip_files = list(clips_dir.glob("*.mp4"))
    assert clip_files, "video clip was not created"

    # raw frame should be gone
    assert not raw_path.exists(), "raw frame should have been deleted"


----- tests/test_user_profile.py -----
# tests/test_user_profile.py

import pytest

@pytest.mark.asyncio
async def test_get_and_update_profile(async_client, signed_up_user):
    _, _, hdrs = signed_up_user
    # get
    me = (await async_client.get("/api/v1/users/me", headers=hdrs)).json()
    assert "email" in me
    # update
    r = await async_client.put("/api/v1/users/me",
        json={"first_name":"New","last_name":"Name"}, headers=hdrs
    )
    assert r.status_code==200
    assert r.json()["first_name"]=="New"


----- tests/virtual_iot.py -----
import multiprocessing
import os
import time
import threading
from typing import Optional, List, Dict, Any

import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

# ============================================================
# In-memory device states
# ============================================================

# Dosing Unit State
_dosing_state = {
    "device_id": "doser-virtual",
    "type": "dosing_unit",
    "version": "1.0.0",
    "ph": 7.2,
    "tds": 450.0,
    "pumps": {},  # pump_number -> count
}

# Valve Controller State
_valve_state = {
    "device_id": "valve-virtual",
    "type": "valve_controller",
    "version": "1.0.0",
    # 4 valves, False=off, True=on
    "valves": [False, False, False, False],
}

# Smart Switch State
_switch_state = {
    "device_id": "switch-virtual",
    "type": "smart_switch",
    "version": "1.0.0",
    # 8 relays, False=off, True=on
    "channels": [False] * 8,
}

# CCTV State
_cctv_state = {
    "device_id": "camera-virtual",
    "type": "cctv",
    "version": "1.0.0",
    "status": "operational",
}

# ============================================================
# Optional “device pulls tasks from cloud” scaffolding
# (off by default; enabled if CLOUD_TASK_BASE is set)
# ============================================================

CLOUD_TASK_BASE = os.getenv("CLOUD_TASK_BASE", "").rstrip("/")
CLOUD_POLL_SEC = float(os.getenv("CLOUD_POLL_SEC", "0"))  # 0 = disabled

# local task queues (simulate what a cloud queue would give us)
_local_queues: Dict[str, List[Dict[str, Any]]] = {
    _valve_state["device_id"]: [],
    _switch_state["device_id"]: [],
    _dosing_state["device_id"]: [],
    _cctv_state["device_id"]: [],
}

def _enqueue_local(device_id: str, task: Dict[str, Any]) -> None:
    _local_queues.setdefault(device_id, []).append(task)

def _dequeue_local(device_id: str) -> Optional[Dict[str, Any]]:
    q = _local_queues.setdefault(device_id, [])
    return q.pop(0) if q else None


def _apply_task(device_id: str, task: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute a queued task against local state.
    Supported:
      - {"type":"valve","valve_id":1,"action":"toggle"}
      - {"type":"switch","channel":2,"action":"toggle"}
      - {"type":"pump","pump_number":1,"amount":10}
    """
    t = task.get("type")
    if t == "valve":
        vid = int(task["valve_id"])
        if not (1 <= vid <= 4):
            return {"error": "invalid valve_id"}
        idx = vid - 1
        _valve_state["valves"][idx] = not _valve_state["valves"][idx]
        return {"valve_id": vid, "new_state": "on" if _valve_state["valves"][idx] else "off"}

    if t == "switch":
        ch = int(task["channel"])
        if not (1 <= ch <= 8):
            return {"error": "invalid channel"}
        idx = ch - 1
        _switch_state["channels"][idx] = not _switch_state["channels"][idx]
        return {"channel": ch, "new_state": "on" if _switch_state["channels"][idx] else "off"}

    if t == "pump":
        pn = int(task.get("pump_number") or task.get("pump") or 0)
        if pn <= 0:
            return {"error": "invalid pump_number"}
        _dosing_state["pumps"][pn] = _dosing_state["pumps"].get(pn, 0) + 1
        return {"message": "pump executed", "pump_number": pn}

    return {"error": "unknown task type"}


def _device_poller(device_id: str):
    """
    Background poller to demonstrate device-pull flow.
    Disabled unless CLOUD_TASK_BASE and CLOUD_POLL_SEC > 0 are set.
    In demo mode we only consume from the local queue.
    """
    if not CLOUD_TASK_BASE or CLOUD_POLL_SEC <= 0:
        return
    while True:
        try:
            # In a real device, this would be:
            #   httpx.get(f"{CLOUD_TASK_BASE}/api/v1/device_comm/pending_tasks?device_id={device_id}", ...)
            task = _dequeue_local(device_id)
            if task:
                _apply_task(device_id, task)
        except Exception:
            pass
        time.sleep(CLOUD_POLL_SEC)


# ============================================================
# Request models
# ============================================================

class PumpCommand(BaseModel):
    pump_number: Optional[int] = None
    pump: Optional[int] = None
    amount: Optional[int] = None
    timestamp: Optional[str] = None

    def resolved_number(self) -> int:
        n = self.pump_number if self.pump_number is not None else self.pump
        if n is None:
            raise ValueError("pump_number or pump is required")
        return int(n)

class ToggleCommand(BaseModel):
    valve_id: Optional[int] = None  # for valve controller
    channel: Optional[int] = None   # for smart switch

class QueueTask(BaseModel):
    type: str
    valve_id: Optional[int] = None
    channel: Optional[int] = None
    pump_number: Optional[int] = None
    pump: Optional[int] = None
    amount: Optional[int] = None


# ============================================================
# App factories
# ============================================================

def create_dosing_app() -> FastAPI:
    app = FastAPI(title="virtual-doser")

    @app.get("/discovery")
    async def discovery():
        return {
            "device_id": _dosing_state["device_id"],
            "type": _dosing_state["type"],
            "version": _dosing_state["version"],
        }

    @app.get("/version")
    async def version():
        return {"version": _dosing_state["version"]}

    @app.get("/monitor")
    async def monitor():
        return {"ph": _dosing_state["ph"], "tds": _dosing_state["tds"]}

    # (Alias often used by callers)
    @app.get("/sensor")
    async def sensor():
        return {"ph": _dosing_state["ph"], "tds": _dosing_state["tds"]}

    @app.post("/pump")
    async def pump(cmd: PumpCommand):
        try:
            num = cmd.resolved_number()
        except ValueError:
            raise HTTPException(status_code=422, detail="pump_number or pump required")
        _dosing_state["pumps"][num] = _dosing_state["pumps"].get(num, 0) + 1
        return {"message": "pump executed", "pump_number": num}

    @app.post("/dose_monitor")
    async def dose_monitor(cmd: PumpCommand):
        try:
            num = cmd.resolved_number()
        except ValueError:
            raise HTTPException(status_code=422, detail="pump_number or pump required")
        _dosing_state["pumps"][num] = _dosing_state["pumps"].get(num, 0) + 1
        return {"message": "combined pump executed", "pump_number": num}

    # Local “cloud queue” test hook
    @app.post("/tasks/push")
    async def push_task(task: QueueTask):
        _enqueue_local(_dosing_state["device_id"], task.dict())
        return {"queued": True}

    @app.post("/pump_calibration")
    async def pump_calibration():
        # emulate a stop/cancel action
        return {"message": "dosing cancelled"}

    # start background poller if enabled
    threading.Thread(target=_device_poller, args=(_dosing_state["device_id"],), daemon=True).start()
    return app


def create_valve_app() -> FastAPI:
    app = FastAPI(title="virtual-valve")

    @app.get("/discovery")
    async def discovery():
        valves = [{"id": i + 1, "state": "on" if st else "off"} for i, st in enumerate(_valve_state["valves"])]
        return {
            "device_id": _valve_state["device_id"],
            "type": _valve_state["type"],
            "version": _valve_state["version"],
            "valves": valves,
        }

    @app.get("/version")
    async def version():
        return {"version": _valve_state["version"]}

    @app.get("/state")
    async def state():
        valves = [{"id": i + 1, "state": "on" if st else "off"} for i, st in enumerate(_valve_state["valves"])]
        return {"device_id": _valve_state["device_id"], "valves": valves}

    @app.post("/toggle")
    async def toggle(cmd: ToggleCommand):
        vid = cmd.valve_id
        if vid is None or not (1 <= vid <= len(_valve_state["valves"])):
            raise HTTPException(status_code=400, detail="Invalid valve_id")
        idx = vid - 1
        _valve_state["valves"][idx] = not _valve_state["valves"][idx]
        return {"valve_id": vid, "new_state": "on" if _valve_state["valves"][idx] else "off"}

    @app.post("/tasks/push")
    async def push_task(task: QueueTask):
        _enqueue_local(_valve_state["device_id"], task.dict())
        return {"queued": True}

    threading.Thread(target=_device_poller, args=(_valve_state["device_id"],), daemon=True).start()
    return app


def create_switch_app() -> FastAPI:
    app = FastAPI(title="virtual-switch")

    @app.get("/discovery")
    async def discovery():
        return {
            "device_id": _switch_state["device_id"],
            "type": _switch_state["type"],
            "version": _switch_state["version"],
        }

    @app.get("/version")
    async def version():
        return {"version": _switch_state["version"]}

    @app.get("/state")
    async def state():
        channels = [{"channel": i + 1, "state": "on" if st else "off"}
                    for i, st in enumerate(_switch_state["channels"])]
        # tests expect "channels"; include "switches" for backwards-compat
        return {
            "device_id": _switch_state["device_id"],
            "channels": channels,
            "switches": channels,  # optional alias
        }

    @app.post("/toggle")
    async def toggle(cmd: ToggleCommand):
        ch = cmd.channel
        if ch is None or not (1 <= ch <= len(_switch_state["channels"])):
            raise HTTPException(status_code=400, detail="Invalid channel")
        idx = ch - 1
        _switch_state["channels"][idx] = not _switch_state["channels"][idx]
        return {"channel": ch, "new_state": "on" if _switch_state["channels"][idx] else "off"}

    @app.post("/tasks/push")
    async def push_task(task: QueueTask):
        _enqueue_local(_switch_state["device_id"], task.dict())
        return {"queued": True}

    threading.Thread(target=_device_poller, args=(_switch_state["device_id"],), daemon=True).start()
    return app


def create_cctv_app() -> FastAPI:
    app = FastAPI(title="virtual-cctv")

    @app.get("/discovery")
    async def discovery():
        return {
            "device_id": _cctv_state["device_id"],
            "type": _cctv_state["type"],
            "version": _cctv_state["version"],
        }

    @app.get("/version")
    async def version():
        return {"version": _cctv_state["version"]}

    @app.get("/status")
    async def status():
        return {
            "camera_id": _cctv_state["device_id"],
            "status": _cctv_state["status"],
        }

    @app.post("/tasks/push")
    async def push_task(task: QueueTask):
        _enqueue_local(_cctv_state["device_id"], task.dict())
        return {"queued": True}

    threading.Thread(target=_device_poller, args=(_cctv_state["device_id"],), daemon=True).start()
    return app


# ============================================================
# Process management
# ============================================================

_EMULATORS = [
    (create_dosing_app, 8001),
    (create_valve_app,  8002),
    (create_switch_app, 8003),
    (create_cctv_app,   8004),
]

_processes: List[multiprocessing.Process] = []


def _run_app(factory, port):
    app = factory()
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")


def start_virtual_iot():
    global _processes
    for factory, port in _EMULATORS:
        p = multiprocessing.Process(target=_run_app, args=(factory, port), daemon=True)
        p.start()
        _processes.append(p)
    # let servers boot
    time.sleep(1.0)


def stop_virtual_iot():
    global _processes
    for p in _processes:
        p.terminate()
        p.join(timeout=1.0)
    _processes.clear()


----- tests/test_farm_endpoints.py -----
# tests/test_farm_endpoints.py

import pytest
import uuid
@pytest.mark.asyncio
async def test_farm_crud_http(async_client, signed_up_user):
    _, _, hdrs = signed_up_user

    # 1) Initial list should be empty
    r = await async_client.get("/api/v1/farms/", headers=hdrs)
    assert r.status_code == 200
    assert r.json() == []

    # 2) Create a farm
    payload = {
        "name": "Test Farm",
        "address": "123 Garden Lane",
        "latitude": 12.34,
        "longitude": 56.78
    }
    r = await async_client.post("/api/v1/farms/", json=payload, headers=hdrs)
    assert r.status_code == 201
    farm = r.json()
    farm_id = farm["id"]
    uuid.UUID(str(farm_id))
    assert farm["name"] == payload["name"]

    # 3) List now contains it
    r = await async_client.get("/api/v1/farms/", headers=hdrs)
    assert any(f["id"] == farm_id for f in r.json())

    # 4) Retrieve by ID
    r = await async_client.get(f"/api/v1/farms/{farm_id}", headers=hdrs)
    assert r.status_code == 200
    assert r.json()["id"] == farm_id

    # 5) Update
    r = await async_client.put(
        f"/api/v1/farms/{farm_id}",
        json={"name": "Renamed Farm"},
        headers=hdrs
    )
    assert r.status_code == 200
    assert r.json()["name"] == "Renamed Farm"

    # 6) Delete
    r = await async_client.delete(f"/api/v1/farms/{farm_id}", headers=hdrs)
    assert r.status_code == 204

    # 7) Now 404 on get
    r = await async_client.get(f"/api/v1/farms/{farm_id}", headers=hdrs)
    assert r.status_code == 404


----- tests/test_auth.py -----
import pytest
from httpx import AsyncClient
from app.main import app
import jwt
import uuid
# Base URL for auth endpoints
AUTH_URL = "/api/v1/auth"

@pytest.fixture
async def signed_up_user(async_client: AsyncClient):
    """
    Creates a user via the signup endpoint and returns (payload, token, headers).
    """
    payload = {
        "email": "user@example.com",
        "password": "string",
        "first_name": "string",
        "last_name": "string",
        "phone": "string",
        "address": "string",
        "city": "string",
        "state": "string",
        "country": "string",
        "postal_code": "string",
        "profile": {
            "first_name": "string",
            "last_name": "string",
            "phone": "string",
            "address": "string",
            "city": "string",
            "state": "string",
            "country": "string",
            "postal_code": "string"
        }
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201
    data = resp.json()
    token = data["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    return payload, token, headers

@pytest.mark.asyncio
async def test_signup_success(async_client: AsyncClient):
    payload = {
        "email": "newuser@example.com",
        "password": "AnotherPass!1",
        "first_name": "string",
        "last_name": "string",
        "phone": "string",
        "address": "string",
        "city": "Delhi",
        "state": "DL",
        "country": "India",
        "postal_code": "110001",
        "profile": {
            "first_name": "Alice",
            "last_name": "Smith",
            "phone": "9876543210",
            "address": "456 Side St",
            "city": "Delhi",
            "state": "DL",
            "country": "India",
            "postal_code": "110001",
        },
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201

    data = resp.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

    user = data["user"]
    # email and role
    assert user["email"] == payload["email"]
    assert user["role"] == "user"

    # nested profile fields should match the payload["profile"], not the top‐level
    prof = user["profile"]
    assert prof["first_name"] == payload["profile"]["first_name"]
    assert prof["last_name"]  == payload["profile"]["last_name"]
    assert prof["city"]       == payload["profile"]["city"]

@pytest.mark.asyncio
async def test_signup_without_nested_profile(async_client: AsyncClient):
    # Only top‐level fields, no "profile" key
    payload = {
        "email": "noprof@example.com",
        "password": "Pass123!",
        "first_name": "Bob",
        "last_name": "Builder",
        "phone": "1231231234",
        "address": "789 Main St",
        "city": "Mumbai",
        "state": "MH",
        "country": "India",
        "postal_code": "400001",
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201

    prof = resp.json()["user"]["profile"]
    # profile should be built from top‐level fields when nested is missing
    assert prof["first_name"] == payload["first_name"]
    assert prof["city"]       == payload["city"]

@pytest.mark.asyncio
async def test_signup_duplicate_email(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 400
    assert resp.json()["detail"] == "Email already registered"

@pytest.mark.asyncio
async def test_signup_invalid_email_format(async_client: AsyncClient):
    payload = {
        "email": "not-an-email",
        "password": "Pass123!",
        "profile": {
            "first_name": "I",
            "last_name": "N",
            "phone": "1112223333",
            "address": "X St",
            "city": "Y",
            "state": "Z",
            "country": "C",
            "postal_code": "000000",
        },
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_signup_missing_fields(async_client: AsyncClient):
    # Missing password (and hence other required top‐level fields)
    resp = await async_client.post(f"{AUTH_URL}/signup", json={"email": "a@b.com"})
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_signup_extra_field(async_client: AsyncClient):
    payload = {
        "email": "extra@example.com",
        "password": "Pass123!",
        "profile": {
            "first_name": "E",
            "last_name": "X",
            "phone": "0000000000",
            "address": "Addr",
            "city": "City",
            "state": "ST",
            "country": "CO",
            "postal_code": "123456",
        },
        "unexpected": "value",   # extra field not allowed
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_login_success(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    form = {"username": payload["email"], "password": payload["password"]}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 200
    data = resp.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"
    assert data["user"]["email"] == payload["email"]

@pytest.mark.asyncio
async def test_login_invalid_password(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    form = {"username": payload["email"], "password": "wrongpass"}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 401
    assert resp.json()["detail"] == "Invalid credentials"

@pytest.mark.asyncio
async def test_login_nonexistent_user(async_client: AsyncClient):
    form = {"username": "nouser@example.com", "password": "nopass"}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 401
    assert resp.json()["detail"] == "Invalid credentials"

@pytest.mark.asyncio
async def test_login_missing_fields(async_client: AsyncClient):
    # Missing password
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data={"username": "user@example.com"},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_token_payload_contains_user_and_role(async_client: AsyncClient, signed_up_user):
    _, token, _ = signed_up_user
    # decode without verifying signature
    decoded = jwt.decode(token, options={"verify_signature": False})
    uuid.UUID(str(decoded.get("user_id")))  
    assert decoded.get("role") == "user"


----- tests/test_subscriptions_edge_cases.py -----
# tests/test_subscriptions_edge_cases.py

import datetime as dt
import pytest
from httpx import AsyncClient
from app.main import app
from app.models import PaymentStatus
import uuid

# ─────────────────────────────────────────────────────────────────────────────
# Admin‐override helper (so we can test both protected & unprotected flows)
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "admin@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _override_admin_dep() -> None:
    """
    Stub out get_current_admin to always return a valid admin.
    """
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin

NONEXISTENT_ID = "00000000-0000-0000-0000-000000000001"
# ─────────────────────────────────────────────────────────────────────────────
# 1) Every /admin/* route must reject non‐admins
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_admin_endpoints_require_admin(async_client: AsyncClient):
    # plan‐CRUD
    r1 = await async_client.post("/admin/plans/", json={})
    assert r1.status_code in (401, 403, 404) 
    r2 = await async_client.put(f"/admin/plans/{NONEXISTENT_ID}", json={})
    assert r2.status_code in (401, 403, 404)
    r3 = await async_client.delete(f"/admin/plans/{NONEXISTENT_ID}")
    assert r3.status_code in (401, 403, 404)

    # payments approve/reject
    r4 = await async_client.post(f"/admin/payments/approve/{NONEXISTENT_ID}")
    assert r4.status_code in (401, 403, 404)
    r5 = await async_client.post(f"/admin/payments/reject/{NONEXISTENT_ID}")
    assert r5.status_code in (401, 403, 404)


# ─────────────────────────────────────────────────────────────────────────────
# 2) Creating a payment with bogus IDs → 404
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_create_payment_invalid_ids(async_client: AsyncClient,
                                          new_user, plan_id, device):
    _, hdrs = new_user

    # nonexistent device
    bad_dev = await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": str(uuid.uuid4()), "plan_id": plan_id},
        headers=hdrs,
    )
    assert bad_dev.status_code == 404

    # nonexistent plan
    bad_plan = await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": str(uuid.uuid4())},
        headers=hdrs,
    )
    assert bad_plan.status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 3) Upload/Confirm/Approve against non‐existent order → 404
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_upload_and_confirm_invalid_order(async_client: AsyncClient,
                                                new_user):
    _, hdrs = new_user

    # upload to invalid order
    up = await async_client.post(
        f"/api/v1/payments/upload/{NONEXISTENT_ID}",
        headers=hdrs,
        files={"file": ("x.jpg", b"X", "image/jpeg")},
    )
    assert up.status_code == 404

    # confirm invalid order
    cf = await async_client.post(
        f"/api/v1/payments/confirm/{NONEXISTENT_ID}",
        json={"upi_transaction_id": "TX"},
        headers=hdrs,
    )
    assert cf.status_code == 404

    # approve invalid order
    _override_admin_dep()
    ap = await async_client.post(
        f"/admin/payments/approve/{NONEXISTENT_ID}",
        headers={"Authorization": "Bearer admin-token"},
    )
    assert ap.status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 4) Expired subscription is marked inactive & blocks device‐linking
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_expired_subscription_marked_inactive(async_client: AsyncClient,
                                                   monkeypatch,
                                                   new_user, plan_id, device):
    # 1) stub admin, purchase & activate
    _override_admin_dep()
    _, hdrs = new_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("p.jpg", b"P", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "T1"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # 2) list subscription → should be active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs and subs[0]["active"] is True
    sub = subs[0]

    # 3) monkeypatch time *past* end_date
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    import app.routers.subscriptions as s_mod
    monkeypatch.setattr(
        s_mod.datetime, "utcnow",
        staticmethod(lambda: end + dt.timedelta(seconds=1))
    )

    # 4) list again → now inactive
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs2 and subs2[0]["active"] is False

    # 5) linking a device on an expired sub → 400
    link = await async_client.post(
        f"/api/v1/subscriptions/{sub['id']}/devices",
        json={"device_id": device},
        headers=hdrs,
    )
    assert link.status_code == 400
    assert "expired" in link.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 5) DELETE a subscription end‐to‐end
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_subscription_deletion(async_client: AsyncClient,
                                     new_user, plan_id, device):
    # 1) stub admin, purchase & activate
    _override_admin_dep()
    _, hdrs = new_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("d.jpg", b"D", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "DEL"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # 2) confirm subscription exists
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sid = subs[0]["id"]

    # 3) delete it
    resp = await async_client.delete(
        f"/api/v1/subscriptions/{sid}",
        headers=hdrs,
    )
    assert resp.status_code == 204

    # 4) now listing returns empty
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs2 == []


----- tests/test_plants_dosing_flow.py -----
# tests/test_plants_dosing_flow.py
import os, importlib
import json
import datetime as dt
import pytest
from httpx import AsyncClient

os.environ.setdefault("USE_OLLAMA", "false")
import app.services.llm as llm_mod
importlib.reload(llm_mod)
import uuid

@pytest.mark.asyncio
async def test_complete_plants_dosing_flow(async_client: AsyncClient, signed_up_user):
    # reuse your signup fixture
    _, _, headers = signed_up_user

    # 1) Create a new farm
    farm_payload = {
        "name": "Integration Farm",
        "address": "123 Test Blvd",
        "latitude": 12.3456,
        "longitude": 65.4321
    }
    farm_resp = await async_client.post(
        "/api/v1/farms/",
        json=farm_payload,
        headers=headers,
    )
    assert farm_resp.status_code == 201
    farm = farm_resp.json()
    farm_id = farm["id"]

    # 2) Create a plant in that farm
    plant_payload = {
        "name": "Test Lettuce",
        "type": "leaf",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Greenhouse",
        "location_description": "Rack 1",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700
    }
    plant_resp = await async_client.post(
        f"/api/v1/farms/{farm_id}/plants/",
        json=plant_payload,
        headers=headers,
    )
    assert plant_resp.status_code == 201
    plant = plant_resp.json()
    plant_id = plant["id"]
    uuid.UUID(str(farm_id)); uuid.UUID(str(plant_id)) 

    # 3) Register a dosing device
    device_payload = {
        "mac_id": "AA:BB:CC:DD",
        "name": "Integration Doser",
        "type": "dosing_unit",
        "http_endpoint": "http://doser.local",
        "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
    }
    dev_resp = await async_client.post(
        "/api/v1/devices/dosing",
        json=device_payload,
        headers=headers,
    )
    assert dev_resp.status_code == 201
    device = dev_resp.json()
    device_id = device["id"]

    # 4) Link the dosing device to our farm
    link = await async_client.post(
        f"/api/v1/farms/{farm_id}/devices",
        json={"device_id": device_id},
        headers=headers,
    )
    assert link.status_code == 200
    # 5) First dosing run
    run1_resp = await async_client.post(
        "/api/v1/dosing/run",
        json={
            "farm_id": farm_id,
            "plant_id": plant_id,
            "device_id": device_id,
        },
        headers=headers,
    )
    assert run1_resp.status_code == 200
    run1 = run1_resp.json()
    assert "actions" in run1 and isinstance(run1["actions"], list) and run1["actions"]
    assert isinstance(run1["actions"][0].get("dose_ml"), (int, float)) and run1["actions"][0]["dose_ml"] > 0
    assert int(run1["actions"][0].get("pump_number", 0)) >= 1

    # 5) Second dosing run (should see two total logs afterwards)
    run2_resp = await async_client.post(
        "/api/v1/dosing/run",
        json={
            "farm_id": farm_id,
            "plant_id": plant_id,
            "device_id": device_id,
        },
        headers=headers,
    )
    assert run2_resp.status_code == 200
    run2 = run2_resp.json()
    assert isinstance(run2["actions"][0].get("dose_ml"), (int, float)) and run2["actions"][0]["dose_ml"] > 0

    # 6) Fetch dosing logs for that plant
    logs_resp = await async_client.get(
        f"/api/v1/farms/{farm_id}/plants/{plant_id}/logs",
        headers=headers,
    )
    assert logs_resp.status_code == 200
    logs = logs_resp.json()
    assert isinstance(logs, list)
    # Expect exactly two entries
    assert len(logs) == 2

    # Verify chronological order
    t1 = dt.datetime.fromisoformat(logs[0]["timestamp"].rstrip("Z"))
    t2 = dt.datetime.fromisoformat(logs[1]["timestamp"].rstrip("Z"))
    assert t1 < t2


@pytest.mark.asyncio
async def test_dosing_run_fails_without_plant(async_client: AsyncClient, signed_up_user):
    # user + headers
    _, _, headers = signed_up_user

    # create a farm (but NO plant)
    farm = (await async_client.post(
        "/api/v1/farms/",
        json={"name":"NoPlant Farm","address":"A","latitude":0,"longitude":0},
        headers=headers,
    )).json()
    farm_id = farm["id"]

    # register a dosing device
    device = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "NP:AA:BB",
            "name": "NoPlant Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://doser.local",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
        },
        headers=headers,
    )).json()["id"]

    # try to run dosing with a bogus plant_id → must fail
    resp = await async_client.post(
        "/api/v1/dosing/run",
        json={"farm_id": farm_id, "plant_id": 999999, "device_id": device},
        headers=headers,
    )
    assert resp.status_code in (400, 404, 422)  # failure expected

----- tests/__init__.py -----


----- tests/test_search_service.py -----
# tests/test_search_service.py
import os
import pytest
from fastapi import HTTPException
from app.services.search_service import serper_search

@pytest.mark.asyncio
@pytest.mark.skipif(
    not os.getenv("SERPER_API_KEY"),
    reason="SERPER_API_KEY not set in environment"
)
async def test_serper_search_real():
    """
    Integration test using the real Serper API and query 'hydroponics india'.
    Requires SERPER_API_KEY in .env or environment variables.
    """
    query = "hydroponics india"
    results = await serper_search(query, num_results=5)

    # Basic shape and content checks
    assert isinstance(results, list), "Expected a list of results"
    assert len(results) > 0, "No results returned from Serper API"

    first = results[0]
    assert "title" in first and first["title"], "First result missing title"
    assert "link" in first and first["link"], "First result missing link"

    print(f"✅ First result: {first['title']} -> {first['link']}")


----- tests/test_payments_extended.py -----
# tests/test_payments_extended.py

import datetime as dt
import pytest
from httpx import AsyncClient

from app.main import app
from app.models import PaymentStatus

# ─────────────────────────────────────────────────────────────────────────────
# Helpers / overrides
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "admin@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _apply_admin_override(monkeypatch):
    """Scope-limited admin override for FastAPI dependency."""
    from app.dependencies import get_current_admin
    monkeypatch.setitem(app.dependency_overrides, get_current_admin, _always_admin)


# ─────────────────────────────────────────────────────────────────────────────
# Fixtures
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture
async def basic_plan(async_client: AsyncClient, signed_up_user, monkeypatch):
    """
    Admin creates a plan with device_limit=1 for testing.
    Override is scoped via monkeypatch so it doesn't leak into other tests.
    """
    _apply_admin_override(monkeypatch)
    resp = await async_client.post(
        "/admin/plans/",
        json={
            "name": "30-day-basic",
            "device_types": ["dosing_unit"],
            "device_limit": 1,
            "duration_days": 30,
            "price": 10000,
        },
        headers={"Authorization": "Bearer x"},
    )
    assert resp.status_code == 201, resp.text
    return resp.json()["id"]

@pytest.fixture
async def dosing_device(async_client: AsyncClient, signed_up_user):
    """
    User registers a dosing device via the public endpoint.
    """
    _, _, hdrs = signed_up_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "FF:EE:AA",
            "name": "Test Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://doser.local",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
        },
        headers=hdrs,
    )
    assert resp.status_code == 201, resp.text
    return resp.json()["id"]


# ─────────────────────────────────────────────────────────────────────────────
# 1) Payment → Subscription creation
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_payment_happy_path_creates_subscription(
    async_client: AsyncClient, signed_up_user, basic_plan, dosing_device, monkeypatch
):
    _apply_admin_override(monkeypatch)
    _, _, hdrs = signed_up_user

    # 1) create order
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    assert PaymentStatus(order["status"]) is PaymentStatus.PENDING
    assert order["qr_code_url"].endswith(".png")
    exp = dt.datetime.fromisoformat(order["expires_at"].rstrip("Z"))
    assert exp > dt.datetime.utcnow()

    # 2) upload proof
    up = await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("proof.jpg", b"\xFF\xD8\xFF", "image/jpeg")},
    )
    assert up.status_code == 200, up.text
    assert up.json()["screenshot_path"].endswith(".jpg")

    # 3) confirm → PROCESSING
    conf = (await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-100"},
        headers=hdrs,
    )).json()
    assert PaymentStatus(conf["status"]) is PaymentStatus.PROCESSING
    assert conf["upi_transaction_id"] == "TXN-100"

    # 4) admin approve → COMPLETED
    done = (await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )).json()
    assert PaymentStatus(done["status"]) is PaymentStatus.COMPLETED

    # 5) subscription is created and active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert len(subs) == 1
    sub = subs[0]
    assert sub["device_id"] == dosing_device
    assert sub["active"] is True
    start = dt.datetime.fromisoformat(sub["start_date"].rstrip("Z"))
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    # exactly 30 days
    assert (end - start).days == 30
    assert sub["device_limit"] == 1


@pytest.mark.asyncio
async def test_double_confirm_errors(
    async_client: AsyncClient, signed_up_user, basic_plan, dosing_device, monkeypatch
):
    _apply_admin_override(monkeypatch)
    _, _, hdrs = signed_up_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload...
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("a.jpg", b"x", "image/jpeg")},
    )
    # first confirm
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-A"},
        headers=hdrs,
    )
    # second confirm
    resp2 = await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-B"},
        headers=hdrs,
    )
    assert resp2.status_code == 400
    assert "current status" in resp2.json()["detail"].lower()


@pytest.mark.asyncio
async def test_admin_auth_required_for_approve(
    async_client: AsyncClient, signed_up_user, basic_plan, dosing_device
):
    # intentionally DO NOT override admin here
    _, _, hdrs = signed_up_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload+confirm
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("p.jpg", b"x", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-Z"},
        headers=hdrs,
    )
    # unauthorized approve
    r = await async_client.post(f"/admin/payments/approve/{order['id']}")
    assert r.status_code in (401, 403)


@pytest.mark.asyncio
async def test_reject_pending(
    async_client: AsyncClient, signed_up_user, basic_plan, dosing_device, monkeypatch
):
    _apply_admin_override(monkeypatch)
    _, _, hdrs = signed_up_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload only
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("r.jpg", b"x", "image/jpeg")},
    )
    # admin reject
    rej = await async_client.post(
        f"/admin/payments/reject/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )
    assert rej.status_code == 200, rej.text
    # JSON returns a string; normalize to enum for comparison
    assert PaymentStatus(rej.json()["status"]) is PaymentStatus.FAILED


# ─────────────────────────────────────────────────────────────────────────────
# 2) Expiry blocks confirm
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_expiry_blocks_confirm(
    async_client: AsyncClient, monkeypatch, signed_up_user, basic_plan, dosing_device
):
    _apply_admin_override(monkeypatch)
    _, _, hdrs = signed_up_user

    import app.routers.payments as pay_mod
    orig = pay_mod.datetime.utcnow
    # make now = 31m before real now, so order.expires_at < real now
    monkeypatch.setattr(
        pay_mod.datetime, "utcnow", staticmethod(lambda: orig() - dt.timedelta(minutes=31))
    )

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()

    # restore real
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(orig))

    # upload proof
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("e.jpg", b"x", "image/jpeg")},
    )
    # confirm should 400 with "expired"
    resp = await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "LATE"},
        headers=hdrs,
    )
    assert resp.status_code == 400
    assert "expired" in resp.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 3) Pro-rated Extension & Device-Linking
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_extension_and_device_linking(
    async_client: AsyncClient, monkeypatch, signed_up_user, basic_plan, dosing_device
):
    _apply_admin_override(monkeypatch)
    _, _, hdrs = signed_up_user

    # Purchase & activate initial subscription
    ord1 = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    await async_client.post(
        f"/api/v1/payments/upload/{ord1['id']}",
        headers=hdrs,
        files={"file": ("1.jpg", b"x", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{ord1['id']}",
        json={"upi_transaction_id": "TXN1"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{ord1['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # get subscription
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sub = subs[0]
    sid = sub["id"]
    start = dt.datetime.fromisoformat(sub["start_date"].rstrip("Z"))
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    assert (end - start).days == 30

    # Half-way through period: monkeypatch now = start + 15d
    import app.routers.payments as pay_mod
    halfway = start + dt.timedelta(days=15)
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(lambda: halfway))

    # Create extension order — price should be half of 10000
    ext = (await async_client.post(
        "/api/v1/payments/create",
        json={"subscription_id": sid, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    assert ext["price"] == 5000

    # Finish extension
    await async_client.post(
        f"/api/v1/payments/upload/{ext['id']}",
        headers=hdrs,
        files={"file": ("2.jpg", b"x", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{ext['id']}",
        json={"upi_transaction_id": "TXN2"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{ext['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # After approve, subscription end = old_end + 30d
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    new_end = dt.datetime.fromisoformat(subs2["end_date"].rstrip("Z"))
    assert (new_end - end).days == 30

    # Device-linking up to device_limit=1 still only allows 1 (second link should fail)
    r1 = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": dosing_device},
        headers=hdrs,
    )
    assert r1.status_code == 200  # original device is fine

    # Register a second device
    second = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "GG:HH:II",
            "name": "Extra",
            "type": "dosing_unit",
            "http_endpoint": "http://extra",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "X"}],
        },
        headers=hdrs,
    )).json()["id"]

    # Limit remains 1 in this flow → second link should fail
    r2 = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": second},
        headers=hdrs,
    )
    assert r2.status_code == 400
    assert "limit" in r2.json()["detail"].lower()


----- tests/test_llm_prompt_fallback.py -----
# tests/test_llm_prompt_fallback.py
import pytest
import asyncio
from app.services.llm import build_plan_prompt

@pytest.mark.asyncio
async def test_build_plan_prompt_no_search_results(monkeypatch):
    # force internal serper search to return empty
    dummy = asyncio.Future()
    dummy.set_result([])
    monkeypatch.setattr(
        "app.services.llm._serper_search",
        lambda q: dummy,
    )

    prompt = await build_plan_prompt(
        sensor_data={},
        profile={"plant_name": "X", "plant_type": "Y"},
        query="anything"
    )
    assert "No external insights found" in prompt


----- tests/test_token_admin.py -----
# tests/test_token_admin.py

import secrets
import uuid
import pytest
from fastapi import HTTPException
from httpx import AsyncClient

from app.main import app
from app.models import Device, DeviceToken, DeviceType
from app.dependencies import verify_device_token, get_current_admin
from app.core.database import AsyncSessionLocal

# -------------------------------------------------------------------
# 1) verify_device_token unit tests
# -------------------------------------------------------------------

@pytest.mark.asyncio
async def test_issue_and_verify_device_token_success(async_client: AsyncClient, create_device):
    """
    Create a device via API, issue a token via admin API, then verify with the dependency.
    """
    # stub admin
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    app.dependency_overrides[get_current_admin] = lambda: dummy_admin
    try:
        resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
        assert resp.status_code == 201, resp.text
        token = resp.json()["token"]

        class Cred:
            credentials = token

        async with AsyncSessionLocal() as db_verify:
            v_id = await verify_device_token(Cred, db_verify, expected_type=DeviceType.DOSING_UNIT)
        assert v_id == create_device
    finally:
        app.dependency_overrides.pop(get_current_admin, None)


@pytest.mark.asyncio
async def test_verify_device_token_invalid_token_raises_401():
    """Nonexistent token should raise a 401."""
    class DummyCred:
        credentials = "totally-invalid-token"

    async with AsyncSessionLocal() as db:
        with pytest.raises(HTTPException) as exc:
            await verify_device_token(
                DummyCred,
                db,
                expected_type=DeviceType.DOSING_UNIT
            )
    assert exc.value.status_code == 401


@pytest.mark.asyncio
async def test_verify_device_token_wrong_type_raises_403(async_client: AsyncClient, create_device):
    """
    Issue a token for a DOSING_UNIT, then verify with expected_type=VALVE_CONTROLLER → 403.
    """
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    app.dependency_overrides[get_current_admin] = lambda: dummy_admin
    try:
        resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
        assert resp.status_code == 201, resp.text
        token = resp.json()["token"]

        class Cred:
            credentials = token

        async with AsyncSessionLocal() as db_verify:
            with pytest.raises(HTTPException) as exc:
                await verify_device_token(Cred, db_verify, expected_type=DeviceType.VALVE_CONTROLLER)
        assert exc.value.status_code == 403
    finally:
        app.dependency_overrides.pop(get_current_admin, None)

@pytest.mark.asyncio
async def test_verify_device_token_inactive_device_raises_403(async_client: AsyncClient, create_device):
    """
    If your build exposes an admin deactivate endpoint, use it; otherwise skip (no DB writes).
    """
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    app.dependency_overrides[get_current_admin] = lambda: dummy_admin
    try:
        # issue a token first
        tok = await async_client.post(f"/admin/device/{create_device}/issue-token")
        assert tok.status_code == 201, tok.text
        token = tok.json()["token"]

        # try deactivation via known admin routes
        tried = False
        for path in (
            f"/admin/device/{create_device}/deactivate",
            f"/admin/devices/{create_device}/deactivate",
        ):
            r = await async_client.post(path, headers={"Authorization": "Bearer admin"})
            if r.status_code in (200, 204):
                tried = True
                break
            if r.status_code not in (404, 405):
                # if your API returns some other code, accept it as success if body says inactive
                tried = True
                break
        if not tried:
            pytest.skip("No admin device deactivate endpoint in this build")

        class Cred:
            credentials = token

        async with AsyncSessionLocal() as db_verify:
            with pytest.raises(HTTPException) as exc:
                await verify_device_token(Cred, db_verify, expected_type=DeviceType.DOSING_UNIT)
        assert exc.value.status_code == 403
    finally:
        app.dependency_overrides.pop(get_current_admin, None)

# -------------------------------------------------------------------
# 2) Admin-only "issue-token" endpoint tests
# -------------------------------------------------------------------

@pytest.fixture
async def create_device(async_client: AsyncClient, signed_up_user):
    """
    Create a new dosing_unit via the public API so we can issue a token for it.
    """
    _, _, headers = signed_up_user
    payload = {
        "mac_id": "AA:BB:CC",
        "name": "Test Doser",
        "type": "dosing_unit",
        "http_endpoint": "http://device.local",
        "pump_configurations": [{"pump_number": 1, "chemical_name": "Water"}],
    }
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json=payload,
        headers=headers,
    )
    assert resp.status_code == 201, "Failed to create device"
    return resp.json()["id"]


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_success(monkeypatch, async_client, create_device):
    """
    Admin can POST /admin/device/{device_id}/issue-token → 201 + JSON{device_id,token}.
    Returned token must authenticate that device.
    """
    # stub out admin auth
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    app.dependency_overrides[get_current_admin] = lambda: dummy_admin


    resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
    assert resp.status_code == 201, resp.text

    data = resp.json()
    assert data["device_id"] == create_device
    assert isinstance(data["token"], str) and len(data["token"]) > 10

    # newly issued token should pass verify_device_token
    new_token = data["token"]
    class Cred:
        credentials = new_token
    async with AsyncSessionLocal() as db_verify:
        v_id = await verify_device_token(Cred, db_verify, expected_type=DeviceType.DOSING_UNIT)
    assert v_id == create_device


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_unauthorized(async_client, create_device):
    """
    Without admin auth, issuing a token must be rejected.
    """
    resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
    assert resp.status_code in (401, 403)


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_404_for_unknown_device(async_client):
    """
    POST /admin/device/{nonexistent}/issue-token should return 404.
    """
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    app.dependency_overrides[get_current_admin] = lambda: dummy_admin
    try:
        resp = await async_client.post(f"/admin/device/{str(uuid.uuid4())}/issue-token")
        assert resp.status_code == 404
        assert "not found" in resp.json().get("detail", "").lower()
    finally:
        app.dependency_overrides.pop(get_current_admin, None)

----- tests/test_supply_chain.py -----
# tests/test_supply_chain.py

import pytest
from fastapi import HTTPException
from app.services.supply_chain_service import extract_json_from_response

def test_extract_json_happy_path():
    s = 'ignore { "a": 1, "b": 2 } trailing'
    out = extract_json_from_response(s)
    assert out == {"a": 1, "b": 2}

def test_extract_json_multiple_json_blocks():
    s = 'prefix {"a":1} middle {"b":2} suffix'
    # should pick up the first JSON object only
    out = extract_json_from_response(s)
    assert out == {"a": 1}

def test_extract_json_nested_objects():
    s = 'foo {"outer":{"inner":123,"list":[1,2,3]}} bar'
    out = extract_json_from_response(s)
    assert out == {"outer": {"inner": 123, "list": [1, 2, 3]}}

def test_extract_json_unicode_and_escapes():
    s = 'pre { "text": "new\\nline", "emoji": "😃" } post'
    out = extract_json_from_response(s)
    # ensure escaped newline is unescaped and unicode preserved
    assert out["text"] == "new\nline"
    assert out["emoji"] == "😃"

def test_extract_json_throws_on_no_json():
    with pytest.raises(HTTPException):
        extract_json_from_response("no JSON here")

def test_extract_json_raises_on_malformed_json_block():
    # unmatched brace / unterminated JSON should error
    with pytest.raises(HTTPException):
        extract_json_from_response("oops { 'a': 1 ")




----- tests/test_plant_service.py -----
# tests/services/test_plant_service.py

import uuid
import pytest
from fastapi import HTTPException
from types import SimpleNamespace

from app.services.plant_service import (
    create_plant,
    list_plants_by_farm,
    get_plant_by_id,
    delete_plant,
)
from app.models import Plant, Farm

# --- fake result/session helpers ---

class DummyResult:
    def __init__(self, items):
        self._items = items
    def scalars(self):
        return self
    def all(self):
        return self._items

class FakePlantSession:
    def __init__(self, plants=None, single=None):
        # plants: what execute(select...) returns
        # single: what get(Farm, id) or get(Plant, id) returns
        self._plants = plants or []
        self._single = single
    async def execute(self, stmt):
        return DummyResult(self._plants)
    async def get(self, model, pk):
        # if asking for Farm, return self._single only if it's a Farm
        if model is Farm and isinstance(self._single, Farm):
            return self._single
        # if asking for Plant, return self._single only if it's a Plant
        if model is Plant and isinstance(self._single, Plant):
            return self._single
        return None
    async def add(self, obj):
        self.last_added = obj
    async def commit(self):
        pass
    async def refresh(self, obj):
        # simulate DB assigning an ID
        if getattr(obj, "id", None) is None:
            obj.id = 123
    async def delete(self, obj):
        pass

# --- tests ---

@pytest.mark.asyncio
async def test_create_plant_requires_existing_farm():
    sess = FakePlantSession(single=None)
    payload = {
        "name": "Lettuce",
        "type": "leaf",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Bangalore",
        "location_description": "Greenhouse",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700,
    }
    with pytest.raises(HTTPException) as exc:
        await create_plant(farm_id=str(uuid.uuid4()), payload=payload, db=sess)
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_create_and_list_plants_success():
    farm_id = str(uuid.uuid4())
    owner_id = str(uuid.uuid4())
    farm = Farm(id=farm_id, owner_id=owner_id, name="FarmX", address="Addr", latitude=0, longitude=0)
    plant = Plant(
        id=None,
        farm_id=farm_id,
        name="Tomato",
        type="fruit",
        growth_stage="flower",
        seeding_date="2025-06-15T00:00:00Z",
        region="Bangalore",
        location_description="Greenhouse",
        location_latitude=12.34,
        location_longitude=56.78,
        target_ph_min=5.8,
        target_ph_max=6.2,
        target_tds_min=400,
        target_tds_max=800
    )
    sess = FakePlantSession(plants=[plant], single=farm)
    # create
    payload = {
        "name": plant.name,
        "type": plant.type,
        "growth_stage": plant.growth_stage,
        "seeding_date": plant.seeding_date,
        "region": plant.region,
        "location_description": plant.location_description,
        "location_latitude": 12.34,
        "location_longitude": 56.78,
        "target_ph_min": plant.target_ph_min,
        "target_ph_max": plant.target_ph_max,
        "target_tds_min": plant.target_tds_min,
        "target_tds_max": plant.target_tds_max,
    }
    new = await create_plant(farm_id=farm_id, payload=payload, db=sess)
    assert isinstance(new, Plant)
    assert new.farm_id == farm_id
    assert new.location_latitude == pytest.approx(12.34)
    assert new.location_longitude == pytest.approx(56.78)
    # list
    plants = await list_plants_by_farm(farm_id=farm_id, db=sess)
    assert plants == [plant]

@pytest.mark.asyncio
async def test_get_plant_by_id_not_found():
    sess = FakePlantSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await get_plant_by_id(str(uuid.uuid4()), db=sess)
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_delete_plant_success_and_missing():
    # delete when missing
    sess1 = FakePlantSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await delete_plant(str(uuid.uuid4()), db=sess1)
    assert exc.value.status_code == 404

    # delete when exists
    p = Plant(id=str(uuid.uuid4()), farm_id=str(uuid.uuid4()), name="Herb", type="herb", growth_stage="seedling",
              seeding_date="2025-07-10T00:00:00Z", region="R", location_description="Home",
              target_ph_min=6.0, target_ph_max=7.0, target_tds_min=200, target_tds_max=600)
    sess2 = FakePlantSession(single=p)
    out = await delete_plant(p.id, db=sess2)
    assert out == {"message": "Plant deleted successfully"}



@pytest.mark.asyncio
async def test_list_plants_empty():
    fid = str(uuid.uuid4())
    sess = FakePlantSession(plants=[], single=SimpleNamespace(id=fid))
    plants = await list_plants_by_farm(farm_id=fid, db=sess)
    assert plants == []

@pytest.mark.asyncio
async def test_get_plant_by_id_success():
    # retrieving an existing plant returns it directly
    p = Plant(
        id=str(uuid.uuid4()), farm_id=str(uuid.uuid4()), name="Basil", type="herb", growth_stage="seed",
        seeding_date="2025-08-01T00:00:00Z", region="Kitchen", location_description="Window",
        target_ph_min=6.0, target_ph_max=7.0, target_tds_min=250, target_tds_max=450
    )
    sess = FakePlantSession(single=p)
    result = await get_plant_by_id(p.id, db=sess)
    assert result is p

----- tests/test_subscriptions_flow.py -----
# tests/test_subscriptions_flow.py
import datetime as _dt
from typing import Tuple

import pytest
from httpx import AsyncClient

from app.main import app
from app.models import PaymentStatus, SubscriptionPlan
from app.core.database import AsyncSessionLocal

# ─────────────────────────────────────────────────────────────────────────────
# Helpers / overrides
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "root@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _override_admin_dep() -> None:
    """Force all @admin routes to succeed."""
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin


# ─────────────────────────────────────────────────────────────────────────────
# Fixtures
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture
async def new_user(async_client: AsyncClient) -> Tuple[str, dict]:
    """
    Create a fresh user via the real signup endpoint,
    return (token, headers).
    """
    payload = {
        "email": "sub@test.io",
        "password": "Pwd!2345",
        "first_name": "Test",
        "last_name": "User",
        "phone": "1234567890",
        "address": "123 Main St",
        "city": "Testville",
        "state": "TS",
        "country": "Testland",
        "postal_code": "000001",
    }
    resp = await async_client.post("/api/v1/auth/signup", json=payload)
    assert resp.status_code == 201
    token = resp.json()["access_token"]
    return token, {"Authorization": f"Bearer {token}"}

async def plan_id(async_client: AsyncClient) -> int:
    """
    Create a plan via the real admin endpoint (device_limit=1) and return its ID.
    """
    _override_admin_dep()
    resp = await async_client.post(
        "/admin/plans/",
        json={
            "name": "30-Day-Basic",
            "device_types": ["dosing_unit"],
            "device_limit": 1,
            "duration_days": 30,
            "price": 10000,
        },
        headers={"Authorization": "Bearer admin-token"},
    )
    if resp.status_code == 404:
        pytest.skip("Admin plan routes are not enabled in this build.")
    assert resp.status_code == 201, resp.text
    return resp.json()["id"]


@pytest.fixture
async def device(async_client: AsyncClient, new_user: Tuple[str, dict]) -> str:
    """
    Register a mock dosing unit (via MockController).
    """
    _, hdrs = new_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "AA:BB:CC",
            "name": "Mock Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://doser",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "Chem"}],
        },
        headers=hdrs,
    )
    assert resp.status_code == 201
    return resp.json()["id"]


# ─────────────────────────────────────────────────────────────────────────────
# 1) ADMIN: CRUD SUBSCRIPTION PLANS
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_admin_plan_crud(async_client: AsyncClient):
    _override_admin_dep()
    hdr = {"Authorization": "Bearer admin-token"}

    # Create
    create = await async_client.post(
        "/admin/plans/",
        json={
            "name": "Basic",
            "device_types": ["dosing_unit"],
            "device_limit": 2,
            "duration_days": 15,
            "price": 5000,
        },
        headers=hdr,
    )
    if create.status_code == 404:
        pytest.skip("Admin plan routes are not enabled in this build.")
    assert create.status_code == 201
    plan = create.json()
    pid = plan["id"]
    assert plan["name"] == "Basic"

    # List
    lst = await async_client.get("/admin/plans/", headers=hdr)
    assert lst.status_code == 200
    assert any(p["id"] == pid for p in lst.json())

    # Retrieve
    get1 = await async_client.get(f"/admin/plans/{pid}", headers=hdr)
    assert get1.status_code == 200
    assert get1.json()["device_limit"] == 2

    # Update
    upd = await async_client.put(
        f"/admin/plans/{pid}",
        json={"name": "Pro", "price": 6000},
        headers=hdr,
    )
    assert upd.status_code == 200
    assert upd.json()["name"] == "Pro"

    # Delete
    rem = await async_client.delete(f"/admin/plans/{pid}", headers=hdr)
    assert rem.status_code == 204
    assert (await async_client.get(f"/admin/plans/{pid}", headers=hdr)).status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 2) USER: VIEW AVAILABLE PLANS
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_user_can_list_plans(async_client: AsyncClient, new_user, plan_id):
    _, hdrs = new_user
    r = await async_client.get("/api/v1/plans/", headers=hdrs)
    assert r.status_code == 200
    assert any(p["id"] == plan_id for p in r.json())


# ─────────────────────────────────────────────────────────────────────────────
# 3) PURCHASE FLOW (PENDING → PROCESSING → COMPLETED)
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_full_purchase_and_activation(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # Create order
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    assert PaymentStatus(order["status"]) is PaymentStatus.PENDING
    assert order["qr_code_url"].endswith(".png")
    expires = _dt.datetime.fromisoformat(order["expires_at"].rstrip("Z"))
    assert expires > _dt.datetime.utcnow()

    # Upload proof
    up = await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.png", b"\xFF\xD8\xFF", "image/png")},
    )
    assert up.status_code == 200
    assert up.json()["screenshot_path"].endswith(".png")

    # Confirm → PROCESSING
    conf = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-001"},
        headers=hdrs,
    )
    assert PaymentStatus(conf.json()["status"]) is PaymentStatus.PROCESSING

    # Admin Approve → COMPLETED
    done = await async_client.post(
        f'/admin/payments/approve/{order["id"]}',
        headers={"Authorization": "Bearer admin-token"},
    )
    assert PaymentStatus(done.json()["status"]) is PaymentStatus.COMPLETED

    # Subscription appears & is active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert len(subs) == 1
    s = subs[0]
    assert s["device_id"] == device
    assert s["active"] is True
    start = _dt.datetime.fromisoformat(s["start_date"].rstrip("Z"))
    end = _dt.datetime.fromisoformat(s["end_date"].rstrip("Z"))
    assert (end - start).days == 30
    assert s["device_limit"] == 1


# ─────────────────────────────────────────────────────────────────────────────
# 4) GUARD-RAILS
#    a) confirm without upload → 400
#    b) double-confirm → 400
#    c) unauthenticated admin approve → 401/403
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_confirm_without_screenshot_fails(async_client: AsyncClient, new_user, plan_id, device):
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "NO-PIC"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "upload" in r.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 5) REJECT FLOW
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_reject_pending_order(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("f.jpg", b"PIC", "image/jpeg")},
    )
    rej = await async_client.post(
        f'/admin/payments/reject/{order["id"]}',
        headers={"Authorization": "Bearer admin-token"},
    )
    assert PaymentStatus(rej.json()["status"]) is PaymentStatus.FAILED


# ─────────────────────────────────────────────────────────────────────────────
# 6) EXPIRY LOGIC
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_order_expiry_blocks_confirm(async_client: AsyncClient, monkeypatch, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    import app.routers.payments as pay_mod
    orig = pay_mod.datetime.utcnow
    # shift “now” back 31m so expires < now
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(lambda: orig() - _dt.timedelta(minutes=31)))

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    # restore real time
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(orig))

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("e.png", b"IMG", "image/png")},
    )
    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "LATE"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "expired" in r.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 7) DEVICE-LINKING & LIMIT ENFORCEMENT
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_cannot_link_more_than_limit(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # purchase & activate
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{order['id']}", headers=hdrs, files={"file":("x.jpg",b"BIN","image/jpeg")})
    await async_client.post(f"/api/v1/payments/confirm/{order['id']}", json={"upi_transaction_id":"1"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{order['id']}", headers={"Authorization":"Bearer admin-token"})

    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sid = subs[0]["id"]

    # register a _second_ device
    d2 = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "DD:EE:FF",
            "name": "Extra",
            "type": "dosing_unit",
            "http_endpoint": "http://extra",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "X"}],
        },
        headers=hdrs,
    )).json()["id"]

    # FAIL: over the plan’s device_limit=1
    r = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": d2},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "limit" in r.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 8) EXTENSION FLOW (INCREASE LIMIT + EXTEND PERIOD)
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_extension_and_then_link_additional(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # 1) initial purchase
    ord1 = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{ord1['id']}", headers=hdrs, files={"file":("a","b","i")})
    await async_client.post(f"/api/v1/payments/confirm/{ord1['id']}", json={"upi_transaction_id":"E1"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ord1['id']}", headers={"Authorization":"Bearer admin-token"})

    subs1 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    sid = subs1["id"]
    start1 = _dt.datetime.fromisoformat(subs1["start_date"].rstrip("Z"))
    end1 = _dt.datetime.fromisoformat(subs1["end_date"].rstrip("Z"))
    assert (end1 - start1).days == 30
    assert subs1["device_limit"] == 1

    # 2) extension payment → bump limit to 2 & +30d
    ext = (await async_client.post(
        "/api/v1/payments/create",
        json={"subscription_id": sid, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{ext['id']}", headers=hdrs, files={"file":("c","d","i")})
    await async_client.post(f"/api/v1/payments/confirm/{ext['id']}", json={"upi_transaction_id":"E2"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ext['id']}", headers={"Authorization":"Bearer admin-token"})

    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    start2 = _dt.datetime.fromisoformat(subs2["start_date"].rstrip("Z"))
    end2 = _dt.datetime.fromisoformat(subs2["end_date"].rstrip("Z"))
    assert subs2["device_limit"] == 2
    assert (end2 - start2).days == 60

    # 3) now linking a second device succeeds
    d3 = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "GG:HH:II",
            "name": "Extra2",
            "type": "dosing_unit",
            "http_endpoint": "http://extra2",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "Y"}],
        },
        headers=hdrs,
    )).json()["id"]

    link = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": d3},
        headers=hdrs,
    )
    assert link.status_code == 200
    assert link.json()["device_id"] == d3


----- tests/test_llm_service.py -----
# tests/test_llm_service.py
"""
Integration-style tests for app.services.llm
-------------------------------------------

These tests exercise:
- Utility functions (no I/O)
- Prompt builders
- A live call against Ollama's HTTP API at /api/models and /api/generate
"""

import os
import re
import json
import pytest
import httpx
from dotenv import load_dotenv

# 1) Load .env and THEN force USE_OLLAMA (and disable TESTING)
ROOT = os.path.dirname(os.path.dirname(__file__))
load_dotenv(os.path.join(ROOT, ".env"))
os.environ.pop("TESTING", None)
os.environ["USE_OLLAMA"] = "true"

# 2) Reload the module so it picks up the new env settings
import importlib
import app.services.llm as llm
importlib.reload(llm)

from app.services.llm import (
    enhance_query,
    parse_json_response,
    parse_ollama_response,
    parse_openai_response,
    validate_llm_response,
    build_dosing_prompt,
    build_plan_prompt,
    call_llm_async,
)

# ───────────────────────────────────────────────────────────────────────────── #
# Helpers for integration checks                                              #
# ───────────────────────────────────────────────────────────────────────────── #

async def is_ollama_up() -> bool:
    """Check that Ollama's HTTP API is reachable at /api/models."""
    base = llm.OLLAMA_URL.rsplit("/api/", 1)[0]
    try:
        async with httpx.AsyncClient(timeout=2) as client:
            r = await client.get(f"{base}/api/models")
            return r.status_code == 200
    except Exception:
        return False

# ───────────────────────────────────────────────────────────────────────────── #
# 1. Pure utility functions (no I/O)                                           #
# ───────────────────────────────────────────────────────────────────────────── #

def test_enhance_query_adds_context():
    q = "Adjust dose"
    profile = {
        "plant_name": "Rose",
        "plant_type": "Flower",
        "growth_stage": "Veg",
        "seeding_date": "2020",
        "location": "Farm",
    }
    out = enhance_query(q, profile)
    assert "Please consider that the plant 'Rose'" in out

def test_enhance_query_no_duplicate_location():
    q = "dose in Farm"
    profile = {"location": "Farm"}
    out = enhance_query(q, profile)
    assert "Please consider that the plant" not in out

def test_parse_json_response_valid_simple():
    # single‐quoted JSON with trailing text
    s = "blah { 'a': 1 , 'b': [2,3] } extra"
    res = parse_json_response(s)
    assert res == {"a": 1, "b": [2, 3]}

def test_parse_json_response_double_quotes_and_nested():
    s = '{"x": {"y":2},"z":3} tail'
    res = parse_json_response(s)
    assert res == {"x": {"y": 2}, "z": 3}

def test_parse_json_response_malformed():
    with pytest.raises(ValueError):
        parse_json_response("no json here")

def test_parse_ollama_response_strips_all_think_blocks():
    raw = "<think>foo</think>   <think>bar</think>   {\"x\":1} tail"
    cleaned = parse_ollama_response(raw)
    assert cleaned.strip() == '{"x":1}'

def test_parse_openai_response_extracts_first_json_block():
    raw = (
        "prefix```analysis\n"
        "{'k':4,'l':[5,6]}\n"
        "```\n"
        "suffix {\"m\":7}"
    )
    out = parse_openai_response(raw)
    # Must be a JSON string with double quotes and valid structure
    assert re.match(r'^\{.*"k"\s*:\s*4.*"l"\s*:\s*\[5,6\].*\}$', out)

def test_parse_openai_response_nested_and_escaped():
    raw = "foo {\"a\":{\"b\":[1,2,3]}} bar"
    out = parse_openai_response(raw)
    parsed = json.loads(out)
    assert parsed == {"a": {"b": [1, 2, 3]}}

def test_parse_openai_response_bad_format():
    with pytest.raises(ValueError):
        parse_openai_response("definitely no braces")

def test_validate_llm_response_good():
    payload = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": 10, "reasoning": "ok"}
        ]
    }
    # should not raise
    validate_llm_response(payload)

def test_validate_llm_response_missing_actions():
    with pytest.raises(ValueError):
        validate_llm_response({})

def test_validate_llm_response_bad_dose():
    bad = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": -5, "reasoning": "oops"}
        ]
    }
    with pytest.raises(ValueError):
        validate_llm_response(bad)

# ───────────────────────────────────────────────────────────────────────────── #
# 2. Prompt builders                                                           #
# ───────────────────────────────────────────────────────────────────────────── #

class _DummyDevice:
    def __init__(self):
        self.id = "d1"
        self.pump_configurations = [
            {"pump_number": 1, "chemical_name": "Chem-A", "chemical_description": "Desc"}
        ]

@pytest.mark.asyncio
async def test_build_dosing_prompt_contains_expected_sections():
    dev = _DummyDevice()
    sensor = {"ph": 6.5, "tds": 300}
    profile = {
        "plant_name": "P",
        "plant_type": "T",
        "growth_stage": "G",
        "seeding_date": "2020",
        "region": "R",
        "location": "L",
        "target_ph_min": 5,
        "target_ph_max": 7,
        "target_tds_min": 100,
        "target_tds_max": 500,
        "dosing_schedule": {},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert re.search(r"(?:- )?pH:\s*6\.5\b", prompt) or re.search(r"Current Sensor Readings:.*pH[^0-9]*6\.5\b", prompt)

@pytest.mark.asyncio
async def test_build_dosing_prompt_raises_when_no_pumps():
    class NoPump:
        id = "x"
        pump_configurations = None
    with pytest.raises(ValueError):
        await build_dosing_prompt(NoPump(), {"ph": 7, "tds": 100}, {})

@pytest.mark.asyncio
async def test_build_plan_prompt_includes_search_insights_or_placeholder():
    sensor_data = {"P": 1, "TDS": 2}
    profile = {
        "plant_name": "TestPlant",
        "plant_type": "Veggie",
        "growth_stage": "Seedling",
        "seeding_date": "2023-01-01",
        "region": "Europe",
        "location": "Berlin",
    }
    prompt = await build_plan_prompt(sensor_data, profile, "optimal growth")
    assert "Detailed Search Insights" in prompt

# ───────────────────────────────────────────────────────────────────────────── #
# 3. Integration: live against local Ollama                                   #
# ───────────────────────────────────────────────────────────────────────────── #

@pytest.mark.asyncio
async def test_call_llm_async_integration():
    # 1) Skip if Ollama isn't running
    if not await is_ollama_up():
        pytest.skip("Local Ollama server not reachable at %s" % llm.OLLAMA_URL)

    # 2) Ask it to return a simple JSON
    prompt = 'Return exactly this JSON: {"foo":42}'
    parsed, raw = await call_llm_async(prompt, llm.OLLAMA_MODEL)

    # 3) Verify the parsed structure
    assert isinstance(parsed, dict)
    assert parsed.get("foo") == 42

    # 4) Verify raw is compact JSON matching parsed
    compact = json.dumps(parsed, separators=(",", ":"))
    assert raw.strip() == compact

def test_parse_openai_response_multiple_fences():
    raw = ("Intro\n```analysis\n"
           "{'a':1}\n```\n"
           "some text\n```analysis\n{'b':2}\n```\n"
           "end")
    out = parse_openai_response(raw)
    # must pick the FIRST valid block
    assert out == '{"a":1}'

@pytest.mark.asyncio
async def test_build_plan_prompt_empty_insights_and_search(monkeypatch):
    # no serper results AND no profile entries
    async def empty_search(q): return []
    monkeypatch.setattr("app.services.llm._serper_search", empty_search)

    prompt = await build_plan_prompt(sensor_data={}, profile={}, query="grow")
    assert "No external insights found" in prompt
    assert "sensor data" in prompt or "plant profile" in prompt  # still include placeholders

----- tests/test_devices.py -----
# tests/test_devices.py
import pytest, httpx, uuid
from app.services.device_controller import DeviceController, get_device_controller


# ----------------------------------------
# Test cases for discovery
# ----------------------------------------
@pytest.mark.asyncio
async def test_discover_via_discovery_endpoint():
    dc = get_device_controller('127.0.0.1:8001')
    data = await dc.discover()
    assert data['device_id'] == 'doser-virtual'
    assert data['type'] == 'dosing_unit'
    assert data['version'] == '1.0.0'
    assert data['ip'] == '127.0.0.1:8001'
@pytest.mark.asyncio
async def test_discover_fallback_to_state_on_discovery_failure(monkeypatch):
    # just discover the real valve controller on port 8002
    dc = DeviceController('127.0.0.1:8002')
    result = await dc.discover()

    assert result['device_id'] == 'valve-virtual'
    assert result['type'] == 'valve_controller'
    assert isinstance(result.get('valves'), list)
    assert len(result['valves']) == 4
    # state can be on/off depending on prior tests; only assert domain
    assert all(v['state'] in ('on', 'off') for v in result['valves'])
    assert result['ip'] == '127.0.0.1:8002'
# ----------------------------------------
# Test cases for version endpoint
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_version_prefers_version_endpoint():
    dc = get_device_controller("127.0.0.1:8001")
    assert await dc.get_version() == "1.0.0"

@pytest.mark.asyncio
async def test_get_version_fallbacks_to_discover_on_error(monkeypatch):
    # with real services we don't exercise fallback; just sanity‐check valve version
    dc = DeviceController('127.0.0.1:8002')
    assert await dc.get_version() == '1.0.0'

# ----------------------------------------
# Test cases for sensor readings
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_sensor_readings_success():
    """
    get_sensor_readings() should parse ph and tds correctly.
    """
    # point at the real virtual dosing unit
    dc = get_device_controller("127.0.0.1:8001")
    readings = await dc.get_sensor_readings()
    assert isinstance(readings, dict)
    assert readings['ph'] == pytest.approx(7.2)
    assert readings['tds'] == pytest.approx(450.0)

@pytest.mark.asyncio
async def test_get_sensor_readings_unreachable():
    """
    get_sensor_readings() against a non-existent endpoint should raise a request error.
    """
    dc = DeviceController("127.0.0.1:9999")
    with pytest.raises(httpx.RequestError):
        await dc.get_sensor_readings()

# ----------------------------------------
# Test cases for dosing operations
# ----------------------------------------
@pytest.mark.asyncio
async def test_execute_dosing_single_and_combined():
    """
    execute_dosing() should call /pump and /dose_monitor based on flag.
    """
    dc = get_device_controller("127.0.0.1:8001")
    single = await dc.execute_dosing(1, 100)
    assert single['message'] == 'pump executed'
    combined = await dc.execute_dosing(2, 50, combined=True)
    assert combined['message'] == 'combined pump executed'

@pytest.mark.asyncio
async def test_cancel_dosing_command():
    """
    cancel_dosing() should post to /pump_calibration with stop command.
    """
    dc = get_device_controller("127.0.0.1:8001")
    res = await dc.cancel_dosing()
    assert res['message'] == 'dosing cancelled'

# ----------------------------------------
# Test cases for valve state and toggle
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_state_success():
    """
    get_state() should fetch full valve state JSON.
    """
    dc = get_device_controller("127.0.0.1:8002")
    state = await dc.get_state()
    assert state['device_id'] == 'valve-virtual'
    assert isinstance(state['valves'], list)
    assert len(state['valves']) == 4
    assert state['valves'][0]['state'] in ('on', 'off')

@pytest.mark.asyncio
async def test_toggle_valve_success():
    """
    toggle_valve() should post to /toggle and return new_state.
    """
    dc = get_device_controller("127.0.0.1:8002")
    state0 = await dc.get_state()
    before = state0["valves"][0]["state"]
    result = await dc.toggle_valve(1)
    after = (await dc.get_state())["valves"][0]["state"]
    assert result["new_state"] in ("on", "off")
    assert after != before

# ----------------------------------------
# Test invalid inputs
# ----------------------------------------
@pytest.mark.asyncio
async def test_toggle_valve_invalid_channel():
    """
    toggle_valve() should raise ValueError if channel not in 1–4.
    """
    dc = get_device_controller("127.0.0.1:8002")
    with pytest.raises(ValueError):
        await dc.toggle_valve(0)

@pytest.mark.asyncio
async def test_get_version_both_fail(monkeypatch):
    """If both /version and /discovery fail, get_version returns None."""
    class DR:
        def __init__(self, code): self.status_code=code
        def json(self): return {}
    class FC:
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def get(self, path, *a,**k):
            return DR(500)  # always error
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *a,**k: FC())
    dc = DeviceController("10.1.1.1")
    v = await dc.get_version()
    assert v is None

# ----------------------------------------
# Test cases for Smart Switch (Device Type "smart_switch")
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_switch_state_success():
    """
    get_state() should fetch full switch state JSON: 8 channels, all off initially.
    """
    dc = get_device_controller("127.0.0.1:8003")
    state = await dc.get_state()
    assert state["device_id"] == "switch-virtual"
    assert isinstance(state["channels"], list)
    assert len(state["channels"]) == 8
    # every channel should start off
    assert all(ch["state"] in ("on", "off") for ch in state["channels"])

@pytest.mark.asyncio
async def test_toggle_switch_success():
    """
    toggle_switch() should flip the named channel from off→on (or vice versa).
    """
    dc = get_device_controller("127.0.0.1:8003")
    # flip channel 2
    res = await dc.toggle_switch(2)
    assert res["channel"] == 2
    assert res["new_state"] in ("on", "off")

@pytest.mark.asyncio
async def test_toggle_switch_invalid_channel():
    """
    toggle_switch() should raise ValueError if channel not in 1–8.
    """
    dc = get_device_controller("127.0.0.1:8003")
    with pytest.raises(ValueError):
        await dc.toggle_switch(0)
    with pytest.raises(ValueError):
        await dc.toggle_switch(9)


# ----------------------------------------
# Test cases for CCTV (Device Type "cctv")
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_cctv_status():
    """
    get_status() should fetch the CCTV operational status.
    """
    dc = get_device_controller("127.0.0.1:8004")
    status = await dc.get_status()
    assert status["camera_id"] == "camera-virtual"
    assert status["status"] == "operational"



@pytest.mark.asyncio
async def test_sensor_roundtrip_via_queue(async_client, signed_up_user):
    """
    Server requests sensor data but cannot hit the device.
    The device later posts the result back (reverse path).
    """
    _, _, hdrs = signed_up_user

    # a) Server enqueues a "read_sensors" request for the dosing unit
    req = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "doser-virtual", "kind": "read_sensors"},
        headers=hdrs,
    )
    assert req.status_code in (200, 201)
    task = req.json()
    tid = task["id"]
    uuid.UUID(str(tid))
    # b) Device polls & executes: we simulate device reading from its local sensors
    #    and POSTing the result back to the cloud
    payload = httpx.get("http://127.0.0.1:8001/sensor", timeout=2.0).json()
    post = await async_client.post(
        f"/api/v1/device_comm/tasks/{tid}/result",
        json={"status": "ok", "payload": payload},
        headers=hdrs,
    )
    assert post.status_code == 200

    # c) Client fetches final result from the task
    fin = (await async_client.get(f"/api/v1/device_comm/tasks/{tid}", headers=hdrs)).json()
    assert fin["status"] == "done"
    assert fin["payload"]["ph"] == pytest.approx(7.2)
    assert fin["payload"]["tds"] == pytest.approx(450.0)



@pytest.mark.asyncio
async def test_sensor_request_offline_stays_queued(async_client, signed_up_user):
    """
    If the device is offline/unregistered, the request still queues,
    but remains pending until a device later picks it up and returns.
    """
    _, _, hdrs = signed_up_user
    req = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "no-such-device", "kind": "read_sensors"},
        headers=hdrs,
    )
    assert req.status_code in (200, 201)
    tid = req.json()["id"]
    uuid.UUID(str(tid))
    # Immediately after, it's still pending
    task = (await async_client.get(f"/api/v1/device_comm/tasks/{tid}", headers=hdrs)).json()
    assert task["status"] in ("queued", "pending")
    assert task.get("payload") is None


@pytest.mark.asyncio
async def test_pump_commands_via_queue(async_client, signed_up_user):
    """
    Server enqueues pump commands; device executes and posts results back.
    """
    _, _, hdrs = signed_up_user

    # Single pump
    req1 = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "doser-virtual",
              "kind": "pump",
              "payload": {"pump_number": 1, "amount": 100}},
        headers=hdrs,
    )
    tid1 = req1.json()["id"]
    uuid.UUID(str(tid1))
    # Device executes locally (emulator) and posts result back to server
    httpx.post("http://127.0.0.1:8001/pump", json={"pump_number": 1, "amount": 100}, timeout=2.0)
    await async_client.post(
        f"/api/v1/device_comm/tasks/{tid1}/result",
        json={"status": "ok", "payload": {"message": "pump executed", "pump_number": 1}},
        headers=hdrs,
    )

    # Combined
    req2 = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "doser-virtual",
              "kind": "pump",
              "payload": {"pump_number": 2, "amount": 50, "combined": True}},
        headers=hdrs,
    )
    tid2 = req2.json()["id"]
    uuid.UUID(str(tid2))
    httpx.post("http://127.0.0.1:8001/dose_monitor", json={"pump_number": 2, "amount": 50}, timeout=2.0)
    await async_client.post(
        f"/api/v1/device_comm/tasks/{tid2}/result",
        json={"status": "ok", "payload": {"message": "combined pump executed", "pump_number": 2}},
        headers=hdrs,
    )

    # Verify both tasks are done
    t1 = (await async_client.get(f"/api/v1/device_comm/tasks/{tid1}", headers=hdrs)).json()
    t2 = (await async_client.get(f"/api/v1/device_comm/tasks/{tid2}", headers=hdrs)).json()
    assert t1["payload"]["message"] == "pump executed"
    assert t2["payload"]["message"] == "combined pump executed"



@pytest.mark.asyncio
async def test_cancel_dosing_via_queue(async_client, signed_up_user):
    _, _, hdrs = signed_up_user

    req = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "doser-virtual", "kind": "cancel_dosing"},
        headers=hdrs,
    )
    tid = req.json()["id"]
    uuid.UUID(str(tid))

    # Device runs local cancel and posts result
    httpx.post("http://127.0.0.1:8001/pump_calibration", timeout=2.0)
    await async_client.post(
        f"/api/v1/device_comm/tasks/{tid}/result",
        json={"status": "ok", "payload": {"message": "dosing cancelled"}},
        headers=hdrs,
    )

    done = (await async_client.get(f"/api/v1/device_comm/tasks/{tid}", headers=hdrs)).json()
    assert done["payload"]["message"] == "dosing cancelled"


# tests/test_devices.py

@pytest.mark.asyncio
async def test_toggle_valve_via_queue(async_client, signed_up_user):
    _, _, hdrs = signed_up_user

    # Enqueue a toggle request
    req = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "valve-virtual", "kind": "valve_toggle", "payload": {"valve_id": 1}},
        headers=hdrs,
    )
    tid = req.json()["id"]
    uuid.UUID(str(tid))
    # Device executes toggle and posts the outcome
    res = httpx.post("http://127.0.0.1:8002/toggle", json={"valve_id": 1}, timeout=2.0).json()
    await async_client.post(
        f"/api/v1/device_comm/tasks/{tid}/result",
        json={"status": "ok", "payload": res},
        headers=hdrs,
    )

    final = (await async_client.get(f"/api/v1/device_comm/tasks/{tid}", headers=hdrs)).json()
    assert final["payload"]["new_state"] in ("on", "off")


@pytest.mark.asyncio
async def test_valve_state_from_cached_after_result(async_client, signed_up_user):
    """
    After a toggle result is posted, platform should expose last-known
    (cached) state without contacting the device.
    """
    _, _, hdrs = signed_up_user

    # Pretend cached state endpoint (to be implemented) shows last-known valves
    # Here we just ensure the route exists & returns a list.
    r = await async_client.get("/api/v1/device_comm/device_state/valve-virtual", headers=hdrs)
    assert r.status_code in (200, 204)
    if r.status_code == 200:
        data = r.json()
        assert isinstance(data.get("valves", []), list)


# tests/test_devices.py

@pytest.mark.asyncio
async def test_switch_toggle_via_queue(async_client, signed_up_user):
    _, _, hdrs = signed_up_user

    # Enqueue a switch toggle
    req = await async_client.post(
        "/api/v1/device_comm/request",
        json={"device_id": "switch-virtual", "kind": "switch_toggle", "payload": {"channel": 2}},
        headers=hdrs,
    )
    tid = req.json()["id"]
    uuid.UUID(str(tid))
    # Device executes & posts result
    res = httpx.post("http://127.0.0.1:8003/toggle", json={"channel": 2}, timeout=2.0).json()
    await async_client.post(
        f"/api/v1/device_comm/tasks/{tid}/result",
        json={"status": "ok", "payload": res},
        headers=hdrs,
    )

    final = (await async_client.get(f"/api/v1/device_comm/tasks/{tid}", headers=hdrs)).json()
    assert final["payload"]["channel"] == 2
    assert final["payload"]["new_state"] in ("on", "off")


@pytest.mark.asyncio
async def test_switch_state_from_cached(async_client, signed_up_user):
    """
    Cached/last-known state for switch (no server→device call).
    """
    _, _, hdrs = signed_up_user
    r = await async_client.get("/api/v1/device_comm/device_state/switch-virtual", headers=hdrs)
    assert r.status_code in (200, 204)
    if r.status_code == 200:
        data = r.json()
        assert isinstance(data.get("channels", []), list)


----- tests/test_dose_manager.py -----
# tests/test_dose_manager.py
import uuid
import pytest

# Use the module directly (new API is function-based)
from app.services import dose_manager as dm


class DummyController:
    def __init__(self, *args, **kw):
        pass

    async def execute_dosing(self, pump, amount, combined=False):
        return {"ok": True, "pump": pump, "amount": amount, "combined": combined}

    async def cancel_dosing(self):
        return {"cancelled": True}


@pytest.fixture(autouse=True)
def patch_controller(monkeypatch):
    # Replace DeviceController inside dose_manager with our dummy
    monkeypatch.setattr(
        "app.services.dose_manager.DeviceController",
        lambda *a, **k: DummyController(),
    )


@pytest.mark.asyncio
async def test_execute_dosing_empty_actions():
    with pytest.raises(ValueError):
        await dm.execute_dosing_operation(str(uuid.uuid4()), "http://x", [], combined=False)

@pytest.mark.asyncio
async def test_execute_dosing_missing_fields():
    # action missing pump_number or dose_ml
    with pytest.raises(ValueError):
        await dm.execute_dosing_operation(str(uuid.uuid4()), "http://x", [{"foo": 1}], combined=True)


@pytest.mark.asyncio
async def test_execute_dosing_success_single_and_combined():
    actions = [{"pump_number": 2, "dose_ml": 25}]
    res = await dm.execute_dosing_operation(str(uuid.uuid4()), "http://x", actions, combined=False)
    assert res["status"] == "command_sent"
    assert res.get("device_id")
    assert res["actions"] == actions

    # combined = True
    res2 = await dm.execute_dosing_operation(str(uuid.uuid4()), "http://x", actions, combined=True)
    assert res2["status"] == "command_sent"
    assert res2["actions"] == actions


@pytest.mark.asyncio
async def test_cancel_dosing_idempotent():
    res = await dm.cancel_dosing_operation(str(uuid.uuid4()), "http://x")
    assert res["status"] == "dosing_cancelled"
    assert res.get("device_id")
    assert res.get("response", {}).get("cancelled") is True

----- tests/test_farm_sharing.py -----
# tests/test_farm_sharing.py

import uuid
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_share_farm_endpoint(async_client, new_user):
    token, hdrs = new_user

    # create farm
    farm = (await async_client.post("/api/v1/farms/", json={
        "name":"S","address":"A","latitude":0,"longitude":0
    }, headers=hdrs)).json()

    # create the target user
    payload = {
        "email": "shared_to@example.com",
        "password": "Pass!234",
        "first_name": "Shared",
        "last_name": "User",
        "phone": "1234567890",
        "address": "1 St",
        "city": "C",
        "state": "S",
        "country": "IN",
        "postal_code": "000000",
    }
    created = (await async_client.post("/api/v1/auth/signup", json=payload)).json()
    target_user_id = created["user"]["id"]

    r1 = await async_client.post(
        f"/api/v1/farms/{farm['id']}/share",
        json={"user_id": target_user_id},
        headers=hdrs
    )
    assert r1.status_code == 200
    assert r1.json()["user_id"] == target_user_id

    # 404 if farm not found
    r2 = await async_client.post(
        f"/api/v1/farms/{str(uuid.uuid4())}/share",
        json={"user_id": target_user_id},
        headers=hdrs
    )
    assert r2.status_code == 404


----- tests/test_farm_service.py -----
# tests/services/test_farm_service.py

import uuid
import pytest
from fastapi import HTTPException
from types import SimpleNamespace

from app.services.farm_service import (
    create_farm,
    list_farms_for_user,
    get_farm_by_id,
    share_farm_with_user,
)
from app.models import Farm

# -------------------------------------------------------------------
# Fake session & result helpers
# -------------------------------------------------------------------

class DummyResult:
    def __init__(self, items):
        self._items = items
    def scalars(self):
        return self
    def all(self):
        return self._items

class FakeFarmSession:
    def __init__(self, farms=None, single=None):
        # single: what get(Farm, pk) will return
        self._farms = farms or []
        self._single = single
        self.last_added = None
        self.committed = False

    async def execute(self, stmt):
        return DummyResult(self._farms)

    async def get(self, model, pk):
        return self._single

    async def add(self, obj):
        self.last_added = obj

    async def commit(self):
        # record that commit() was called
        self.committed = True

    async def refresh(self, obj):
        # no-op for tests
        pass

# -------------------------------------------------------------------
# Tests
# -------------------------------------------------------------------

@pytest.mark.asyncio
async def test_create_farm_success():
    sess = FakeFarmSession()
    owner_id = str(uuid.uuid4())
    payload = {
        "name": "Test Farm",
        "address": "123 Garden Lane",
        "latitude": 12.9716,
        "longitude": 77.5946
    }

    farm = await create_farm(owner_id=owner_id, payload=payload, db=sess)

    # it's a real ORM object
    assert isinstance(farm, Farm)
    assert farm.owner_id == owner_id
    assert farm.name == payload["name"]
    assert farm.address == payload["address"]
    assert pytest.approx(farm.latitude) == payload["latitude"]
    assert pytest.approx(farm.longitude) == payload["longitude"]

@pytest.mark.asyncio
async def test_get_farm_by_id_not_found():
    sess = FakeFarmSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await get_farm_by_id(99, db=sess)
    # 404 when missing
    assert exc.value.status_code == 404
    assert "not found" in exc.value.detail.lower()

@pytest.mark.asyncio
async def test_list_farms_for_user():
    user_id = str(uuid.uuid4())
    f1 = Farm(id=str(uuid.uuid4()), owner_id=user_id, name="A", address="AddrA", latitude=0, longitude=0)
    f2 = Farm(id=str(uuid.uuid4()), owner_id=user_id, name="B", address="AddrB", latitude=1, longitude=1)
    sess = FakeFarmSession(farms=[f1, f2])

    farms = await list_farms_for_user(user_id=user_id, db=sess)

    # we get back exactly what we seeded
    assert farms == [f1, f2]

@pytest.mark.asyncio
async def test_share_farm_not_found():
    sess = FakeFarmSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await share_farm_with_user(farm_id=5, user_id=11, db=sess)
    # still a 404 for missing farm
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_share_farm_success_records_and_returns_association():
    # prepare a farm
    farm = Farm(id=str(uuid.uuid4()), owner_id=str(uuid.uuid4()), name="Shared Farm", address="X", latitude=0, longitude=0)
    sess = FakeFarmSession(single=farm)
    sub_user_id = 99

    assoc = await share_farm_with_user(farm_id=7, user_id=sub_user_id, db=sess)

    # 1) check you added exactly that object to the session
    assert sess.last_added is assoc

    # 2) check you committed
    assert sess.committed is True

    # 3) and that the return has the right attributes
    assert isinstance(assoc, SimpleNamespace)
    assert assoc.farm_id == farm.id
    assert assoc.user_id == sub_user_id


@pytest.mark.asyncio
async def test_get_farm_by_id_success():
    # retrieving a known farm yields the exact ORM object
    farm = Farm(id=str(uuid.uuid4()), owner_id=str(uuid.uuid4()), name="Farm8", address="Addr8", latitude=8.8, longitude=9.9)
    sess = FakeFarmSession(single=farm)
    result = await get_farm_by_id(farm.id, db=sess)
    assert result is farm

@pytest.mark.asyncio
async def test_list_farms_for_user_empty():
    # user with no farms returns []
    sess = FakeFarmSession(farms=[])
    farms = await list_farms_for_user(user_id=str(uuid.uuid4()), db=sess)
    assert farms == []

----- tests/test_build_dosing_prompt.py -----
# tests/test_build_dosing_prompt.py
import re
import pytest
from app.services.llm import build_dosing_prompt

class DummyDev:
    def __init__(self, pumps=None):
        self.id = "dev-x"
        self.pump_configurations = pumps or [
            {"pump_number": 1, "chemical_name": "A", "chemical_description": "Alpha"},
            {"pump_number": 2, "chemical_name": "B", "chemical_description": "Beta"},
        ]

@pytest.mark.asyncio
async def test_build_dosing_prompt_includes_schedule_and_sensors():
    dev = DummyDev()
    sensor = {"ph": 6.0, "tds": 250}
    profile = {
        "plant_name": "Herb",
        "plant_type": "Leafy",
        "growth_stage": "Flower",
        "seeding_date": "2021-01-01",
        "region": "Green",
        "location": "Zone A",
        "target_ph_min": 5.5, "target_ph_max": 6.5,
        "target_tds_min": 200, "target_tds_max": 300,
        "dosing_schedule": {"morning": "08:00", "evening": "20:00"},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    # pumps
    assert "Pump 1: A" in prompt and "Pump 2: B" in prompt
    # sensor readings summary (single line with colon)
    assert re.search(r"Current.+pH:\s*6\.0", prompt)
    assert re.search(r"Current.+TDS:\s*250", prompt)
    # schedule section
    assert "morning" in prompt and "08:00" in prompt
    assert "evening" in prompt and "20:00" in prompt
    # JSON-only instruction
    assert "Return ONLY a JSON object" in prompt

@pytest.mark.asyncio
async def test_prompt_formats_numbers_cleanly():
    dev = DummyDev()
    sensor = {"ph": 5.83, "tds": 300.0}
    profile = {
        "plant_name": "X", "plant_type": "Y", "growth_stage": "Z",
        "seeding_date": "2021-01-01", "region": "R", "location": "L",
        "target_ph_min": 5.5, "target_ph_max": 6.5,
        "target_tds_min": 200, "target_tds_max": 400,
        "dosing_schedule": {"noon": "12:00"},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert "pH: 5.8" in prompt  # single decimal
    assert re.search(r"TDS:\s*300\b", prompt)

@pytest.mark.asyncio
async def test_pumps_are_sorted_and_description_optional():
    dev = DummyDev(pumps=[
        {"pump_number": 3, "chemical_name": "Buffer", "chemical_description": None},
        {"pump_number": 1, "chemical_name": "Acid", "chemical_description": "pH Up"},
    ])
    sensor = {"ph": 6.0, "tds": 250}
    profile = {
        "plant_name": "A", "plant_type": "B", "growth_stage": "C",
        "seeding_date": "2020-01-01", "region": "R", "location": "L",
        "target_ph_min": 5.5, "target_ph_max": 6.5,
        "target_tds_min": 200, "target_tds_max": 300,
        "dosing_schedule": {},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    # Order check: Pump 1 appears before Pump 3
    assert prompt.index("Pump 1: Acid") < prompt.index("Pump 3: Buffer")
    # No double space/strange punctuation if description missing
    assert "Pump 3: Buffer —" not in prompt

@pytest.mark.asyncio
async def test_missing_schedule_is_handled_gracefully():
    dev = DummyDev()
    sensor = {"ph": 6.0, "tds": 250}
    profile = {
        "plant_name": "A", "plant_type": "B", "growth_stage": "C",
        "seeding_date": "2020-01-01", "region": "R", "location": "L",
        "target_ph_min": 5.5, "target_ph_max": 6.5,
        "target_tds_min": 200, "target_tds_max": 300,
        # no dosing_schedule
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert "Dosing Schedule:" in prompt
    assert "(none)" in prompt

@pytest.mark.asyncio
async def test_targets_and_profile_block_present():
    dev = DummyDev()
    sensor = {"ph": 6.0, "tds": 250}
    profile = {
        "plant_name": "Herb", "plant_type": "Leafy", "growth_stage": "Flower",
        "seeding_date": "2021-01-01", "region": "Green", "location": "Zone A",
        "target_ph_min": 5.5, "target_ph_max": 6.5,
        "target_tds_min": 200, "target_tds_max": 300,
        "dosing_schedule": {"morning": "08:00"},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert "Plant Profile:" in prompt
    assert "- plant_name: Herb" in prompt
    # Make sure both bounds appear on the same line for pH/TDS targets
    assert re.search(r"- pH:\s*5\.5\s*-\s*6\.5", prompt)
    assert re.search(r"- TDS:\s*200\s*-\s*300\b", prompt)


----- tests/test_supply_chain_endpoint.py -----
# tests/test_supply_chain_endpoint.py

import pytest

@pytest.mark.asyncio
async def test_supply_chain_extract_endpoint(async_client, signed_up_user):
    _, _, hdrs = signed_up_user
    body = "Here’s some text {\"foo\":1}"
    r = await async_client.post(
      "/api/v1/supply-chain/extract", json={"text":body}, headers=hdrs
    )
    assert r.status_code==200
    assert r.json()=={"foo":1}


