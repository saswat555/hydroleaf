======= Directory: tests =======

----- tests/test_detailed_cases.py -----
# tests/test_detailed_cases.py

import asyncio
import importlib
import os

import pytest
import httpx
from fastapi import HTTPException

from app.services.device_controller import DeviceController
from app.services.llm import call_llm_async, USE_OLLAMA, MODEL_1_5B
from app.services.supply_chain_service import extract_json_from_response
from app.services.llm import parse_json_response, build_dosing_prompt
from app.models import Device

# -----------------------------
# 1) Discover fallback ’ip’
# -----------------------------
@pytest.mark.asyncio
async def test_discover_fallback_ip_strips_http_prefix(monkeypatch):
    class DummyRes:
        def __init__(self, code, data):
            self.status_code = code
            self._json = data
        def json(self):
            return self._json

    class FakeCli:
        def __init__(self, *a, **k): pass
        async def __aenter__(self): return self
        async def __aexit__(self, *a): pass
        async def get(self, path, *a, **k):
            if path == "/discovery":
                return DummyRes(500, {})
            if path == "/state":
                return DummyRes(200, {"device_id": "X", "valves": []})
            return DummyRes(404, {})

    monkeypatch.setattr(httpx, "AsyncClient", lambda *a, **k: FakeCli())

    dc = DeviceController("10.0.0.5")
    result = await dc.discover()
    assert result["ip"] == "10.0.0.5"
    assert "http://" not in result["ip"]

# -----------------------------
# 2) extract_json_from_response
# -----------------------------
def test_extract_json_happy_path():
    s = 'ignore { "a": 1, "b": 2 } trailing'
    out = extract_json_from_response(s)
    assert out == {"a": 1, "b": 2}

def test_extract_json_throws_on_no_json():
    with pytest.raises(HTTPException):
        extract_json_from_response("no JSON here")
# -----------------------------
# 3) call_llm_async live integration
# -----------------------------
@pytest.mark.asyncio
async def test_call_llm_async_live():
    """
    Invoke the real LLM backend.  If USE_OLLAMA, hits Ollama; otherwise OpenAI.
    """
    prompt = 'Return exactly this JSON: {"foo":42}'
    if USE_OLLAMA:
        # Ollama must be reachable
        parsed, raw = await call_llm_async(prompt, MODEL_1_5B)
        assert isinstance(parsed, dict)
        assert parsed.get("foo") == 42
    else:
        # OPENAI_API_KEY must be set
        key = os.getenv("OPENAI_API_KEY")
        assert key, "OPENAI_API_KEY must be set for OpenAI integration tests"
        model = os.getenv("GPT_MODEL") or "gpt-3.5-turbo"
        parsed, raw = await call_llm_async(prompt, model)
        assert isinstance(parsed, dict)
        assert parsed.get("foo") == 42

# -----------------------------
# 4) build_dosing_prompt errors
# -----------------------------
@pytest.mark.asyncio
async def test_build_dosing_prompt_raises_on_no_pumps():
    dummy = Device(
        id="d1",
        mac_id="m",
        name="n",
        type="dosing_unit",
        http_endpoint="e",
        pump_configurations=None,
        sensor_parameters={},
        valve_configurations=[],
        switch_configurations=[]
    )
    with pytest.raises(ValueError):
        await build_dosing_prompt(dummy, {"ph": 7, "tds": 100}, {})

# -----------------------------
# 5) parse_json_response edge
# -----------------------------
def test_parse_json_response_strips_extra_text():
    s = "junk { 'x': 10 } more junk"
    out = parse_json_response(s)
    assert out == {"x": 10}

@pytest.mark.asyncio
async def test_discover_both_endpoints_fail(monkeypatch):
    class DummyRes:
        def __init__(self, code): self.status_code = code
        def json(self): return {}
    class FakeCli:
        async def __aenter__(self): return self
        async def __aexit__(self, *a): pass
        async def get(self, path, *a, **k):
            return DummyRes(500)  # always fail
    monkeypatch.setattr(httpx, "AsyncClient", lambda *a, **k: FakeCli())

    dc = DeviceController("10.0.0.99")
    result = await dc.discover()
    assert result is None

def test_extract_json_multiple_json_blocks():
    s = 'prefix {"a":1} middle {"b":2} suffix'
    out = extract_json_from_response(s)
    assert out == {"a": 1}

# -----------------------------
# 6) call_llm_async ollama error propagation
# -----------------------------
@pytest.mark.asyncio
async def test_call_llm_async_ollama_http_error():
    import app.services.llm as llm
    if not llm.USE_OLLAMA:
        pytest.skip("USE_OLLAMA=false – skipping Ollama branch")

    # An empty prompt should provoke a 400 from Ollama
    with pytest.raises(HTTPException):
        await call_llm_async("", llm.MODEL_1_5B)

# -----------------------------
# 7) parse_json_response top-level list
# -----------------------------
def test_parse_json_response_top_level_list():
    s = "[ {'x':10}, {'y':20} ] extra"
    out = parse_json_response(s)
    assert isinstance(out, list)
    assert out == [{"x": 10}, {"y": 20}]

# -----------------------------
# 8) build_dosing_prompt many pumps
# -----------------------------
@pytest.mark.asyncio
async def test_build_dosing_prompt_many_pumps():
    class D:
        def __init__(self):
            self.pump_configurations = [
                {"pump_number": i, "chemical_name": f"C{i}", "chemical_description": "D"}
                for i in range(1, 5)
            ]
            self.id = "X"
    dev = D()
    sensor = {"ph": 7, "tds": 100}
    profile = {
        "plant_name": "P", "plant_type": "T", "growth_stage": "G",
        "seeding_date": "2020", "region": "R", "location": "L",
        "target_ph_min": 5, "target_ph_max": 8,
        "target_tds_min": 50, "target_tds_max": 150,
        "dosing_schedule": {}
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    for i in range(1, 5):
        assert f"Pump {i}:" in prompt


----- tests/conftest.py -----
# tests/conftest.py
"""
Pytest fixtures for Hydroleaf:

- Loads .env and forces TESTING=1
- Spins up a dedicated Postgres DB (TEST_DATABASE_URL)
- Overrides FastAPI’s DB dependency to use that same session
- Truncates every table after each test
- Provides an httpx.AsyncClient + a deterministic DeviceController mock
- Logs the result of each test to test_logs.txt
"""

import os
import sys
import datetime as _dt
from pathlib import Path
from dotenv import load_dotenv

# 1) Load .env from project root, then force TESTING
ROOT = Path(__file__).resolve().parents[1]
load_dotenv(ROOT / ".env", override=False)
os.environ["TESTING"] = "1"

# 2) Ensure project root is on sys.path
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

# 3) Now import FastAPI app, database, etc.
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import create_engine, text
from sqlalchemy.pool import NullPool
import jwt as _jwt
import uuid
# patch out JWT signature checks in tests
_orig_jwt_decode = _jwt.decode
def _decode_no_key(token, key=None, algorithms=None, options=None, **kwargs):
    return _orig_jwt_decode(token, key or "", algorithms=algorithms,
                            options={**(options or {}), "verify_signature": False}, **kwargs)
_jwt.decode = _decode_no_key

# import the config so that TESTING=True picks up TEST_DATABASE_URL
import app.core.config  # noqa: F401

# Grab the test‐DB URL
TEST_DB_URL = os.getenv(
    "TEST_DATABASE_URL",
    "postgresql+asyncpg://postgres:1234@localhost:5432/hydroleaf_test",
)

# Async engine + sessionmaker for tests (no pooling)
_test_engine = create_async_engine(
    TEST_DB_URL, echo=False, future=True, poolclass=NullPool
)
TestSessionLocal = async_sessionmaker(
    _test_engine, class_=AsyncSession, expire_on_commit=False
)

# Override the app’s AsyncSessionLocal
import app.core.database as _db_mod
_db_mod.AsyncSessionLocal = TestSessionLocal

# Import application and dependency
from app.main import app
from app.core.database import Base, get_db

def pytest_configure(config):
    """
    If pytest-cov is available, enable coverage of the 'app' package
    and show missing lines in the terminal report by default.
    """
    cov = config.pluginmanager.getplugin("cov")
    if cov:
        config.option.cov_source = ["app"]
        config.option.cov_report = ["term-missing"]
        
@pytest.fixture(scope="session", autouse=True)
async def _setup_db_and_overrides():
    # Create tables once
    async with _test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # Dependency override for get_db
    async def _override_get_db() -> AsyncSession:
        async with TestSessionLocal() as session:
            try:
                yield session
                await session.commit()
            except:
                await session.rollback()
                raise

    app.dependency_overrides[get_db] = _override_get_db

    # Make all admin routes succeed
    try:
        from app.routers.admin_subscriptions import get_current_admin
        app.dependency_overrides[get_current_admin] = lambda: True
    except ImportError:
        pass

    yield
    # teardown is handled by table‐truncation fixture below

# Create a synchronous engine for table truncation
_SYNC_DB_URL = TEST_DB_URL.replace(
    "postgresql+asyncpg://", "postgresql+psycopg2://"
)
_sync_engine = create_engine(_SYNC_DB_URL, future=True)

@pytest.fixture(autouse=True)
def _truncate_tables_after_each_test():
    yield
    # Truncate all tables to reset state
    with _sync_engine.begin() as conn:
        conn.execute(text("SET session_replication_role = replica;"))
        for tbl in reversed(Base.metadata.sorted_tables):
            conn.execute(text(f'TRUNCATE TABLE "{tbl.name}" RESTART IDENTITY CASCADE'))
        conn.execute(text("SET session_replication_role = DEFAULT;"))

# ───── DeviceController mock ─────
class MockController:
    def __init__(self, device_ip: str, request_timeout: float = 10.0):
        self.device_ip = device_ip

    async def discover(self):
        suffix_map = {
            "dosing": {"device_id": "dev-dosing", "name": "Mock Dosing", "type": "dosing_unit"},
            "sensor": {"device_id": "dev-sensor", "name": "Mock Sensor", "type": "ph_tds_sensor"},
            "valve": {"device_id": "dev-valve",  "name": "Mock Valve",  "type": "valve_controller"},
            "switch": {"device_id": "dev-switch", "name": "Mock Switch", "type": "smart_switch"},
        }
        for suf, payload in suffix_map.items():
            if self.device_ip.endswith(suf):
                return {**payload, "ip": self.device_ip}
        return None

@pytest.fixture(autouse=True)
def _patch_device_controller(monkeypatch, request):
    if "async_client" in request.fixturenames:
        import app.services.device_controller as dc_mod
        monkeypatch.setattr(dc_mod, "DeviceController", MockController)

# ───── Camera data root helper ─────
@pytest.fixture(autouse=True)
def _temp_cam_root(tmp_path, monkeypatch):
    monkeypatch.setenv("CAM_DATA_ROOT", str(tmp_path))
    # reload config so HLS paths update
    from importlib import reload
    reload(__import__("app.core.config"))
    yield

# ───── Async HTTP client ─────
@pytest.fixture
async def async_client():
    async with AsyncClient(app=app, base_url="http://testserver") as client:
        yield client

# ───── Test‐result logging ─────
_LOG_PATH = ROOT / "test_logs.txt"

def pytest_sessionstart(session):
    with _LOG_PATH.open("w", encoding="utf-8") as fp:
        fp.write(f"Test run started: {_dt.datetime.utcnow().isoformat()}Z\n")
        fp.write("=" * 70 + "\n")

def pytest_runtest_logreport(report):
    if report.when != "call":
        return
    outcome = "PASSED" if report.passed else "FAILED" if report.failed else "SKIPPED"
    ts = _dt.datetime.utcnow().isoformat() + "Z"
    with _LOG_PATH.open("a", encoding="utf-8") as fp:
        fp.write(f"{ts} | {report.nodeid} | {outcome} | {getattr(report,'duration',0):.2f}s\n")
        if report.failed:
            fp.write("--- Failure details below ---\n")
            longrepr = getattr(report, "longreprtext", None) or str(report.longrepr)
            fp.write(f"{longrepr}\n")
            if cap := getattr(report, "capstderr", None):
                fp.write(f"--- stderr ---\n{cap}\n")
            fp.write("-" * 70 + "\n")


----- tests/test_camera_tasks.py -----
# tests/test_camera_tasks.py
"""
Quick sanity-check that the camera_tasks pipeline

• moves raw → processed
• starts (or appends to) a clip writer
"""

import asyncio
from pathlib import Path

import cv2
import numpy as np
import pytest


# ─────────────────────────────────────────────────────────────────────────────
# Point CAM_DATA_ROOT at pytest’s tmp dir for every test in this module
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture(autouse=True)
def _temp_data_root(tmp_path, monkeypatch):
    monkeypatch.setenv("CAM_DATA_ROOT", str(tmp_path))
    # ensure any module-level constants are regenerated
    from importlib import reload
    reload(__import__("app.core.config"))
    yield


@pytest.mark.asyncio
async def test_encode_and_cleanup_creates_processed_and_clip(tmp_path, monkeypatch):
    cam_id = "cam_test"

    # Import after env var is set so camera_tasks sees the new CAM_DATA_ROOT.
    from app.utils import camera_tasks

    # Ask the library for the canonical folder layout ↓↓↓
    raw_dir, processed_dir, clips_dir = camera_tasks._ensure_dirs(cam_id)

    # ── make one dummy 320 × 240 JPEG in the *right* raw folder ──────────────
    img = np.zeros((240, 320, 3), dtype=np.uint8)
    cv2.putText(img, "dummy", (50, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

    raw_path = raw_dir / "1.jpg"
    raw_dir.mkdir(parents=True, exist_ok=True)          # in case helper skipped it
    cv2.imwrite(str(raw_path), img)

    # Skip YOLO – make _annotate() a cheap no-op that returns zero detections
    monkeypatch.setattr(camera_tasks, "_annotate", lambda x: (x, []))

    # ── run the pipeline ────────────────────────────────────────────────────
    await camera_tasks.encode_and_cleanup(cam_id)

    # ── assertions ─────────────────────────────────────────────────────────
    # processed JPEG present
    proc_files = list(processed_dir.glob("*_processed.jpg"))
    assert len(proc_files) == 1, "processed frame was not written"

    # at least one .mp4 in the clip directory
    clip_files = list(clips_dir.glob("*.mp4"))
    assert clip_files, "video clip was not created"

    # raw frame should be gone
    assert not raw_path.exists(), "raw frame should have been deleted"


----- tests/test_auth.py -----
import pytest
from httpx import AsyncClient
from app.main import app
import jwt

# Base URL for auth endpoints
AUTH_URL = "/api/v1/auth"

@pytest.fixture
async def signed_up_user(async_client: AsyncClient):
    """
    Creates a user via the signup endpoint and returns (payload, token, headers).
    """
    payload = {
        "email": "user@example.com",
        "password": "string",
        "first_name": "string",
        "last_name": "string",
        "phone": "string",
        "address": "string",
        "city": "string",
        "state": "string",
        "country": "string",
        "postal_code": "string",
        "profile": {
            "first_name": "string",
            "last_name": "string",
            "phone": "string",
            "address": "string",
            "city": "string",
            "state": "string",
            "country": "string",
            "postal_code": "string"
        }
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201
    data = resp.json()
    token = data["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    return payload, token, headers

@pytest.mark.asyncio
async def test_signup_success(async_client: AsyncClient):
    payload = {
        "email": "newuser@example.com",
        "password": "AnotherPass!1",
        "first_name": "string",
        "last_name": "string",
        "phone": "string",
        "address": "string",
        "city": "Delhi",
        "state": "DL",
        "country": "India",
        "postal_code": "110001",
        "profile": {
            "first_name": "Alice",
            "last_name": "Smith",
            "phone": "9876543210",
            "address": "456 Side St",
            "city": "Delhi",
            "state": "DL",
            "country": "India",
            "postal_code": "110001",
        },
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201

    data = resp.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

    user = data["user"]
    # email and role
    assert user["email"] == payload["email"]
    assert user["role"] == "user"

    # nested profile fields should match the payload["profile"], not the top‐level
    prof = user["profile"]
    assert prof["first_name"] == payload["profile"]["first_name"]
    assert prof["last_name"]  == payload["profile"]["last_name"]
    assert prof["city"]       == payload["profile"]["city"]

@pytest.mark.asyncio
async def test_signup_without_nested_profile(async_client: AsyncClient):
    # Only top‐level fields, no "profile" key
    payload = {
        "email": "noprof@example.com",
        "password": "Pass123!",
        "first_name": "Bob",
        "last_name": "Builder",
        "phone": "1231231234",
        "address": "789 Main St",
        "city": "Mumbai",
        "state": "MH",
        "country": "India",
        "postal_code": "400001",
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 201

    prof = resp.json()["user"]["profile"]
    # profile should be built from top‐level fields when nested is missing
    assert prof["first_name"] == payload["first_name"]
    assert prof["city"]       == payload["city"]

@pytest.mark.asyncio
async def test_signup_duplicate_email(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 400
    assert resp.json()["detail"] == "Email already registered"

@pytest.mark.asyncio
async def test_signup_invalid_email_format(async_client: AsyncClient):
    payload = {
        "email": "not-an-email",
        "password": "Pass123!",
        "profile": {
            "first_name": "I",
            "last_name": "N",
            "phone": "1112223333",
            "address": "X St",
            "city": "Y",
            "state": "Z",
            "country": "C",
            "postal_code": "000000",
        },
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_signup_missing_fields(async_client: AsyncClient):
    # Missing password (and hence other required top‐level fields)
    resp = await async_client.post(f"{AUTH_URL}/signup", json={"email": "a@b.com"})
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_signup_extra_field(async_client: AsyncClient):
    payload = {
        "email": "extra@example.com",
        "password": "Pass123!",
        "profile": {
            "first_name": "E",
            "last_name": "X",
            "phone": "0000000000",
            "address": "Addr",
            "city": "City",
            "state": "ST",
            "country": "CO",
            "postal_code": "123456",
        },
        "unexpected": "value",   # extra field not allowed
    }
    resp = await async_client.post(f"{AUTH_URL}/signup", json=payload)
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_login_success(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    form = {"username": payload["email"], "password": payload["password"]}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 200
    data = resp.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"
    assert data["user"]["email"] == payload["email"]

@pytest.mark.asyncio
async def test_login_invalid_password(async_client: AsyncClient, signed_up_user):
    payload, _, _ = signed_up_user
    form = {"username": payload["email"], "password": "wrongpass"}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 401
    assert resp.json()["detail"] == "Invalid credentials"

@pytest.mark.asyncio
async def test_login_nonexistent_user(async_client: AsyncClient):
    form = {"username": "nouser@example.com", "password": "nopass"}
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data=form,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 401
    assert resp.json()["detail"] == "Invalid credentials"

@pytest.mark.asyncio
async def test_login_missing_fields(async_client: AsyncClient):
    # Missing password
    resp = await async_client.post(
        f"{AUTH_URL}/login",
        data={"username": "user@example.com"},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert resp.status_code == 422

@pytest.mark.asyncio
async def test_token_payload_contains_user_and_role(async_client: AsyncClient, signed_up_user):
    _, token, _ = signed_up_user
    # decode without verifying signature
    decoded = jwt.decode(token, options={"verify_signature": False})
    assert decoded.get("user_id") is not None
    assert decoded.get("role") == "user"


----- tests/test_subscriptions_edge_cases.py -----
# tests/test_subscriptions_edge_cases.py

import datetime as dt
import pytest
from httpx import AsyncClient
from app.main import app
from app.models import PaymentStatus

# ─────────────────────────────────────────────────────────────────────────────
# Admin‐override helper (so we can test both protected & unprotected flows)
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "admin@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _override_admin_dep() -> None:
    """
    Stub out get_current_admin to always return a valid admin.
    """
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin


# ─────────────────────────────────────────────────────────────────────────────
# 1) Every /admin/* route must reject non‐admins
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_admin_endpoints_require_admin(async_client: AsyncClient):
    # plan‐CRUD
    r1 = await async_client.post("/admin/plans/", json={})
    assert r1.status_code in (401, 403)
    r2 = await async_client.put("/admin/plans/1", json={})
    assert r2.status_code in (401, 403)
    r3 = await async_client.delete("/admin/plans/1")
    assert r3.status_code in (401, 403)

    # payments approve/reject
    r4 = await async_client.post("/admin/payments/approve/1")
    assert r4.status_code in (401, 403)
    r5 = await async_client.post("/admin/payments/reject/1")
    assert r5.status_code in (401, 403)


# ─────────────────────────────────────────────────────────────────────────────
# 2) Creating a payment with bogus IDs → 404
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_create_payment_invalid_ids(async_client: AsyncClient,
                                          new_user, plan_id, device):
    _, hdrs = new_user

    # nonexistent device
    bad_dev = await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": "no-such", "plan_id": plan_id},
        headers=hdrs,
    )
    assert bad_dev.status_code == 404

    # nonexistent plan
    bad_plan = await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": 9999},
        headers=hdrs,
    )
    assert bad_plan.status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 3) Upload/Confirm/Approve against non‐existent order → 404
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_upload_and_confirm_invalid_order(async_client: AsyncClient,
                                                new_user):
    _, hdrs = new_user

    # upload to invalid order
    up = await async_client.post(
        "/api/v1/payments/upload/9999",
        headers=hdrs,
        files={"file": ("x.jpg", b"X", "image/jpeg")},
    )
    assert up.status_code == 404

    # confirm invalid order
    cf = await async_client.post(
        "/api/v1/payments/confirm/9999",
        json={"upi_transaction_id": "TX"},
        headers=hdrs,
    )
    assert cf.status_code == 404

    # approve invalid order
    _override_admin_dep()
    ap = await async_client.post(
        "/admin/payments/approve/9999",
        headers={"Authorization": "Bearer admin-token"},
    )
    assert ap.status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 4) Expired subscription is marked inactive & blocks device‐linking
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_expired_subscription_marked_inactive(async_client: AsyncClient,
                                                   monkeypatch,
                                                   new_user, plan_id, device):
    # 1) stub admin, purchase & activate
    _override_admin_dep()
    _, hdrs = new_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("p.jpg", b"P", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "T1"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # 2) list subscription → should be active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs and subs[0]["active"] is True
    sub = subs[0]

    # 3) monkeypatch time *past* end_date
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    import app.routers.subscriptions as s_mod
    monkeypatch.setattr(
        s_mod.datetime, "utcnow",
        staticmethod(lambda: end + dt.timedelta(seconds=1))
    )

    # 4) list again → now inactive
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs2 and subs2[0]["active"] is False

    # 5) linking a device on an expired sub → 400
    link = await async_client.post(
        f"/api/v1/subscriptions/{sub['id']}/devices",
        json={"device_id": device},
        headers=hdrs,
    )
    assert link.status_code == 400
    assert "expired" in link.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 5) DELETE a subscription end‐to‐end
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_subscription_deletion(async_client: AsyncClient,
                                     new_user, plan_id, device):
    # 1) stub admin, purchase & activate
    _override_admin_dep()
    _, hdrs = new_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("d.jpg", b"D", "image/jpeg")},
    )
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "DEL"},
        headers=hdrs,
    )
    await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )

    # 2) confirm subscription exists
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sid = subs[0]["id"]

    # 3) delete it
    resp = await async_client.delete(
        f"/api/v1/subscriptions/{sid}",
        headers=hdrs,
    )
    assert resp.status_code == 204

    # 4) now listing returns empty
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert subs2 == []


----- tests/test_plants_dosing_flow.py -----
# tests/test_plants_dosing_flow.py

import json
import datetime as dt
import pytest
from httpx import AsyncClient

import app.services.llm as llm_mod
from app.services.llm import call_llm_async as real_call_llm


@pytest.fixture(autouse=True)
def fake_llm(monkeypatch):
    """
    Replace call_llm_async with a deterministic fake that always returns
    one action of 5 mL on pump 1.
    """
    async def _fake_call_llm(prompt, model):
        parsed = {
            "actions": [
                {
                    "pump_number": 1,
                    "chemical_name": "N",
                    "dose_ml": 5,
                    "reasoning": "unit test dosing"
                }
            ]
        }
        raw = json.dumps(parsed)
        return parsed, raw

    monkeypatch.setattr(llm_mod, "call_llm_async", _fake_call_llm)
    yield
    # restore real LLM after tests
    monkeypatch.setattr(llm_mod, "call_llm_async", real_call_llm)


@pytest.mark.asyncio
async def test_complete_plants_dosing_flow(async_client: AsyncClient, signed_up_user):
    # reuse your signup fixture
    _, _, headers = signed_up_user

    # 1) Create a new farm
    farm_payload = {
        "name": "Integration Farm",
        "address": "123 Test Blvd",
        "latitude": 12.3456,
        "longitude": 65.4321
    }
    farm_resp = await async_client.post(
        "/api/v1/farms/",
        json=farm_payload,
        headers=headers,
    )
    assert farm_resp.status_code == 201
    farm = farm_resp.json()
    farm_id = farm["id"]

    # 2) Create a plant in that farm
    plant_payload = {
        "name": "Test Lettuce",
        "type": "leaf",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Greenhouse",
        "location_description": "Rack 1",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700
    }
    plant_resp = await async_client.post(
        f"/api/v1/farms/{farm_id}/plants/",
        json=plant_payload,
        headers=headers,
    )
    assert plant_resp.status_code == 201
    plant = plant_resp.json()
    plant_id = plant["id"]

    # 3) Register a dosing device
    device_payload = {
        "mac_id": "AA:BB:CC:DD",
        "name": "Integration Doser",
        "type": "dosing_unit",
        "http_endpoint": "http://doser.local",
        "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
    }
    dev_resp = await async_client.post(
        "/api/v1/devices/dosing",
        json=device_payload,
        headers=headers,
    )
    assert dev_resp.status_code == 201
    device = dev_resp.json()
    device_id = device["id"]

    # 4) Link the dosing device to our farm
    link = await async_client.post(
        f"/api/v1/farms/{farm_id}/devices",
        json={"device_id": device_id},
        headers=headers,
    )
    assert link.status_code == 200
    # 5) First dosing run
    run1_resp = await async_client.post(
        "/api/v1/dosing/run",
        json={
            "farm_id": farm_id,
            "plant_id": plant_id,
            "device_id": device_id,
        },
        headers=headers,
    )
    assert run1_resp.status_code == 200
    run1 = run1_resp.json()
    assert "actions" in run1 and isinstance(run1["actions"], list)
    assert run1["actions"][0]["dose_ml"] == 5
    assert run1["actions"][0]["pump_number"] == 1

    # 5) Second dosing run (should see two total logs afterwards)
    run2_resp = await async_client.post(
        "/api/v1/dosing/run",
        json={
            "farm_id": farm_id,
            "plant_id": plant_id,
            "device_id": device_id,
        },
        headers=headers,
    )
    assert run2_resp.status_code == 200
    run2 = run2_resp.json()
    assert run2["actions"][0]["dose_ml"] == 5

    # 6) Fetch dosing logs for that plant
    logs_resp = await async_client.get(
        f"/api/v1/farms/{farm_id}/plants/{plant_id}/logs",
        headers=headers,
    )
    assert logs_resp.status_code == 200
    logs = logs_resp.json()
    assert isinstance(logs, list)
    # Expect exactly two entries
    assert len(logs) == 2

    # Verify chronological order
    t1 = dt.datetime.fromisoformat(logs[0]["timestamp"].rstrip("Z"))
    t2 = dt.datetime.fromisoformat(logs[1]["timestamp"].rstrip("Z"))
    assert t1 < t2


----- tests/test_payments_extended.py -----
# tests/test_payments_extended.py

import datetime as dt
import pytest
from httpx import AsyncClient

from app.main import app
from app.models import PaymentStatus, SubscriptionPlan

# ─────────────────────────────────────────────────────────────────────────────
# Helpers / overrides
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "admin@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _override_admin_dep():
    """Stub out admin auth for all @admin routes."""
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin


# ─────────────────────────────────────────────────────────────────────────────
# Fixtures
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture
async def basic_plan(async_client: AsyncClient, signed_up_user):
    """
    Admin creates a plan with device_limit=1 for testing.
    """
    _override_admin_dep()
    resp = await async_client.post(
        "/admin/plans/",
        json={
            "name": "30-day-basic",
            "device_types": ["dosing_unit"],
            "device_limit": 1,
            "duration_days": 30,
            "price_cents": 10000,
        },
        headers={"Authorization": "Bearer x"},
    )
    assert resp.status_code == 201
    return resp.json()["id"]

@pytest.fixture
async def dosing_device(async_client: AsyncClient, signed_up_user):
    """
    User registers a dosing device via the public endpoint.
    """
    _, _, hdrs = signed_up_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "FF:EE:AA",
            "name": "Test Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://doser.local",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "N"}],
        },
        headers=hdrs,
    )
    assert resp.status_code == 201
    return resp.json()["id"]


# ─────────────────────────────────────────────────────────────────────────────
# 1) Admin Plan CRUD
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_admin_plan_crud(async_client: AsyncClient):
    _override_admin_dep()
    hdr = {"Authorization": "Bearer admin-token"}

    # Create
    create = await async_client.post(
        "/admin/plans/",
        json={
            "name": "Pro",
            "device_types": ["dosing_unit"],
            "device_limit": 2,
            "duration_days": 60,
            "price_cents": 20000,
        },
        headers=hdr,
    )
    assert create.status_code == 201
    plan = create.json()
    pid = plan["id"]
    assert plan["name"] == "Pro"

    # List
    lst = await async_client.get("/admin/plans/", headers=hdr)
    assert lst.status_code == 200
    assert any(p["id"] == pid for p in lst.json())

    # Retrieve
    get1 = await async_client.get(f"/admin/plans/{pid}", headers=hdr)
    assert get1.status_code == 200
    assert get1.json()["device_limit"] == 2

    # Update
    upd = await async_client.put(
        f"/admin/plans/{pid}",
        json={"device_limit": 3, "price_cents": 25000},
        headers=hdr,
    )
    assert upd.status_code == 200
    body = upd.json()
    assert body["device_limit"] == 3
    assert body["price_cents"] == 25000

    # Delete
    rem = await async_client.delete(f"/admin/plans/{pid}", headers=hdr)
    assert rem.status_code == 204
    # now 404
    assert (await async_client.get(f"/admin/plans/{pid}", headers=hdr)).status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 2) User lists available plans
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_user_can_list_plans(async_client: AsyncClient, signed_up_user, basic_plan):
    _, hdrs = signed_up_user
    r = await async_client.get("/api/v1/plans/", headers=hdrs)
    assert r.status_code == 200
    plans = r.json()
    assert any(p["id"] == basic_plan for p in plans)


# ─────────────────────────────────────────────────────────────────────────────
# 3) Payment → Subscription creation
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_payment_happy_path_creates_subscription(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user

    # 1) create order
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    assert PaymentStatus(order["status"]) is PaymentStatus.PENDING
    assert order["qr_code_url"].endswith(".png")
    exp = dt.datetime.fromisoformat(order["expires_at"].rstrip("Z"))
    assert exp > dt.datetime.utcnow()

    # 2) upload proof
    up = await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("proof.jpg", b"\xFF\xD8\xFF", "image/jpeg")},
    )
    assert up.status_code == 200
    assert up.json()["screenshot_path"].endswith(".jpg")

    # 3) confirm → PROCESSING
    conf = (await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-100"},
        headers=hdrs,
    )).json()
    assert PaymentStatus(conf["status"]) is PaymentStatus.PROCESSING
    assert conf["upi_transaction_id"] == "TXN-100"

    # 4) admin approve → COMPLETED
    done = (await async_client.post(
        f"/admin/payments/approve/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )).json()
    assert PaymentStatus(done["status"]) is PaymentStatus.COMPLETED

    # 5) subscription is created and active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert len(subs) == 1
    sub = subs[0]
    assert sub["device_id"] == dosing_device
    assert sub["active"] is True
    start = dt.datetime.fromisoformat(sub["start_date"].rstrip("Z"))
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    # exactly 30 days
    assert (end - start).days == 30
    assert sub["device_limit"] == 1


# ─────────────────────────────────────────────────────────────────────────────
# 4) Reject and error flows
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_confirm_without_screenshot_fails(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    _, hdrs = signed_up_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()

    r = await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "NO-SCREEN"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "upload" in r.json()["detail"].lower()

@pytest.mark.asyncio
async def test_double_confirm_errors(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload...
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("a.jpg", b"x", "image/jpeg")},
    )
    # first confirm
    await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-A"},
        headers=hdrs,
    )
    # second confirm
    resp2 = await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "TXN-B"},
        headers=hdrs,
    )
    assert resp2.status_code == 400
    assert "current status" in resp2.json()["detail"].lower()

@pytest.mark.asyncio
async def test_admin_auth_required_for_approve(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    # no override
    _, hdrs = signed_up_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload+confirm
    await async_client.post(f"/api/v1/payments/upload/{order['id']}", headers=hdrs,
                            files={"file": ("p.jpg", b"x", "image/jpeg")})
    await async_client.post(f"/api/v1/payments/confirm/{order['id']}",
                            json={"upi_transaction_id": "TXN-Z"}, headers=hdrs)
    # unauthorized approve
    r = await async_client.post(f"/admin/payments/approve/{order['id']}")
    assert r.status_code in (401, 403)

@pytest.mark.asyncio
async def test_reject_pending(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    # upload only
    await async_client.post(f"/api/v1/payments/upload/{order['id']}", headers=hdrs,
                            files={"file": ("r.jpg", b"x", "image/jpeg")})
    # admin reject
    rej = await async_client.post(
        f"/admin/payments/reject/{order['id']}",
        headers={"Authorization": "Bearer admin-token"},
    )
    assert rej.status_code == 200
    assert rej.json()["status"] == PaymentStatus.FAILED


# ─────────────────────────────────────────────────────────────────────────────
# 5) Expiry blocks confirm
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_expiry_blocks_confirm(async_client: AsyncClient, monkeypatch, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user

    import app.routers.payments as pay_mod
    orig = pay_mod.datetime.utcnow
    # make now = 31m before real now, so order.expires_at < real now
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(lambda: orig() - dt.timedelta(minutes=31)))

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()

    # restore real
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(orig))

    # upload proof
    await async_client.post(
        f"/api/v1/payments/upload/{order['id']}",
        headers=hdrs,
        files={"file": ("e.jpg", b"x", "image/jpeg")},
    )
    # confirm should 400 with "expired"
    resp = await async_client.post(
        f"/api/v1/payments/confirm/{order['id']}",
        json={"upi_transaction_id": "LATE"},
        headers=hdrs,
    )
    assert resp.status_code == 400
    assert "expired" in resp.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 6) Pro-rated Extension & Device-Linking
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_extension_and_device_linking(async_client: AsyncClient, signed_up_user, basic_plan, dosing_device):
    _override_admin_dep()
    _, hdrs = signed_up_user

    # Purchase & activate initial subscription
    ord1 = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": dosing_device, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{ord1['id']}", headers=hdrs,
                            files={"file": ("1.jpg", b"x", "image/jpeg")})
    await async_client.post(f"/api/v1/payments/confirm/{ord1['id']}",
                            json={"upi_transaction_id": "TXN1"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ord1['id']}",
                            headers={"Authorization": "Bearer admin-token"})

    # get subscription
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sub = subs[0]
    sid = sub["id"]
    start = dt.datetime.fromisoformat(sub["start_date"].rstrip("Z"))
    end = dt.datetime.fromisoformat(sub["end_date"].rstrip("Z"))
    assert (end - start).days == 30

    # Half-way through period: monkeypatch now = start + 15d
    import app.routers.payments as pay_mod
    monkeypatch_time = start + dt.timedelta(days=15)
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(lambda: monkeypatch_time))

    # Create extension order — price_cents should be roughly 5000 (half of 10000)
    ext = (await async_client.post(
        "/api/v1/payments/create",
        json={"subscription_id": sid, "plan_id": basic_plan},
        headers=hdrs,
    )).json()
    assert ext["price_cents"] == 5000

    # Finish extension
    await async_client.post(f"/api/v1/payments/upload/{ext['id']}", headers=hdrs,
                            files={"file": ("2.jpg", b"x", "image/jpeg")})
    await async_client.post(f"/api/v1/payments/confirm/{ext['id']}",
                            json={"upi_transaction_id": "TXN2"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ext['id']}",
                            headers={"Authorization": "Bearer admin-token"})

    # After approve, subscription end = old_end + 30d
    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    new_end = dt.datetime.fromisoformat(subs2["end_date"].rstrip("Z"))
    assert (new_end - end).days == 30

    # Device-linking up to device_limit=1 still only allows 1
    r1 = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": dosing_device},
        headers=hdrs,
    )
    # should succeed for the original device
    assert r1.status_code == 200

    # Register a second device
    second = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "GG:HH:II",
            "name": "Extra",
            "type": "dosing_unit",
            "http_endpoint": "http://extra",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "X"}],
        },
        headers=hdrs,
    )).json()["id"]

    # Now limit = 1 + (extended?) → we expect limit still 1, so this fails
    r2 = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": second},
        headers=hdrs,
    )
    assert r2.status_code == 400
    assert "limit" in r2.json()["detail"].lower()


----- tests/test_token_admin.py -----
# tests/test_token_admin.py

import secrets
import pytest
from fastapi import HTTPException
from httpx import AsyncClient

from app.main import app
from app.models import Device, DeviceToken, DeviceType
from app.dependencies import verify_device_token, get_current_admin
from app.core.database import AsyncSessionLocal

# -------------------------------------------------------------------
# 1) verify_device_token unit tests
# -------------------------------------------------------------------

@pytest.mark.asyncio
async def test_issue_and_verify_device_token_success():
    """
    Manually insert a Device + DeviceToken row, then verify_device_token returns its ID.
    """
    # 1. create device and token in the same transaction
    async with AsyncSessionLocal() as db:
        async with db.begin():
            dev = Device(
                id="dev-1",
                mac_id="mac-1",
                name="Demo",
                type=DeviceType.DOSING_UNIT,
                http_endpoint="http://example",
                is_active=True,
            )
            db.add(dev)

            token = secrets.token_urlsafe(16)
            db.add(DeviceToken(
                device_id=dev.id,
                token=token,
                device_type=dev.type,
            ))
    # 2. verify it
    class DummyCred:
        credentials = token

    async with AsyncSessionLocal() as db_verify:
        device_id = await verify_device_token(
            DummyCred,
            db_verify,
            expected_type=DeviceType.DOSING_UNIT
        )
    assert device_id == "dev-1"


@pytest.mark.asyncio
async def test_verify_device_token_invalid_token_raises_401():
    """Nonexistent token should raise a 401."""
    class DummyCred:
        credentials = "totally-invalid-token"

    async with AsyncSessionLocal() as db:
        with pytest.raises(HTTPException) as exc:
            await verify_device_token(
                DummyCred,
                db,
                expected_type=DeviceType.DOSING_UNIT
            )
    assert exc.value.status_code == 401


@pytest.mark.asyncio
async def test_verify_device_token_wrong_type_raises_403():
    """
    If the token exists but the device_type doesn’t match expected_type,
    verify_device_token should raise a 403.
    """
    # Insert a valve_controller token
    async with AsyncSessionLocal() as db:
        async with db.begin():
            dev = Device(
                id="dev-2",
                mac_id="mac-2",
                name="Demo2",
                type=DeviceType.VALVE_CONTROLLER,
                http_endpoint="http://example",
                is_active=True,
            )
            db.add(dev)

            token = secrets.token_urlsafe(16)
            db.add(DeviceToken(
                device_id=dev.id,
                token=token,
                device_type=dev.type,
            ))
    class DummyCred:
        credentials = token

    # Now expect DOSING_UNIT, but token’s device_type is VALVE_CONTROLLER
    async with AsyncSessionLocal() as db_verify:
        with pytest.raises(HTTPException) as exc:
            await verify_device_token(
                DummyCred,
                db_verify,
                expected_type=DeviceType.DOSING_UNIT
            )
    assert exc.value.status_code == 403


@pytest.mark.asyncio
async def test_verify_device_token_inactive_device_raises_403():
    """Tokens for inactive devices should be rejected."""
    async with AsyncSessionLocal() as db:
        async with db.begin():
            dev = Device(
                id="dev-3",
                mac_id="mac-3",
                name="Demo3",
                type=DeviceType.DOSING_UNIT,
                http_endpoint="http://example",
                is_active=False,
            )
            db.add(dev)

            token = secrets.token_urlsafe(16)
            db.add(DeviceToken(
                device_id=dev.id,
                token=token,
                device_type=dev.type,
            ))
    class DummyCred:
        credentials = token

    async with AsyncSessionLocal() as db_verify:
        with pytest.raises(HTTPException) as exc:
            await verify_device_token(
                DummyCred,
                db_verify,
                expected_type=DeviceType.DOSING_UNIT
            )
    assert exc.value.status_code == 403

# -------------------------------------------------------------------
# 2) Admin-only "issue-token" endpoint tests
# -------------------------------------------------------------------

@pytest.fixture
async def create_device(async_client: AsyncClient, signed_up_user):
    """
    Create a new dosing_unit via the public API so we can issue a token for it.
    """
    _, _, headers = signed_up_user
    payload = {
        "mac_id": "AA:BB:CC",
        "name": "Test Doser",
        "type": "dosing_unit",
        "http_endpoint": "http://device.local",
        "pump_configurations": [{"pump_number": 1, "chemical_name": "Water"}],
    }
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json=payload,
        headers=headers,
    )
    assert resp.status_code == 201, "Failed to create device"
    return resp.json()["id"]


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_success(monkeypatch, async_client, create_device):
    """
    Admin can POST /admin/device/{device_id}/issue-token → 201 + JSON{device_id,token}.
    Returned token must authenticate that device.
    """
    # stub out admin auth
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    monkeypatch.setattr(get_current_admin, "__call__", lambda _: dummy_admin)

    resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
    assert resp.status_code == 201, resp.text

    data = resp.json()
    assert data["device_id"] == create_device
    assert isinstance(data["token"], str) and len(data["token"]) > 10

    # newly issued token should pass verify_device_token
    new_token = data["token"]
    class Cred:
        credentials = new_token
    async with AsyncSessionLocal() as db_verify:
        v_id = await verify_device_token(Cred, db_verify, expected_type=DeviceType.DOSING_UNIT)
    assert v_id == create_device


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_unauthorized(async_client, create_device):
    """
    Without admin auth, issuing a token must be rejected.
    """
    resp = await async_client.post(f"/admin/device/{create_device}/issue-token")
    assert resp.status_code in (401, 403)


@pytest.mark.asyncio
async def test_admin_issue_token_endpoint_404_for_unknown_device(monkeypatch, async_client):
    """
    POST /admin/device/{nonexistent}/issue-token should return 404.
    """
    # stub admin
    dummy_admin = type("A", (), {"id": 1, "role": "superadmin"})()
    monkeypatch.setattr(get_current_admin, "__call__", lambda _: dummy_admin)

    resp = await async_client.post("/admin/device/nonexistent/issue-token")
    assert resp.status_code == 404
    assert "not found" in resp.json().get("detail", "").lower()


----- tests/test_plant_service.py -----
# tests/services/test_plant_service.py

import pytest
from fastapi import HTTPException
from app.services.plant_service import (
    create_plant,
    list_plants_by_farm,
    get_plant_by_id,
    delete_plant,
)
from app.models import Plant, Farm

# --- fake result/session helpers ---

class DummyResult:
    def __init__(self, items):
        self._items = items
    def scalars(self):
        return self
    def all(self):
        return self._items

class FakePlantSession:
    def __init__(self, plants=None, single=None):
        # plants: what execute(select...) returns
        # single: what get(Farm, id) or get(Plant, id) returns
        self._plants = plants or []
        self._single = single
    async def execute(self, stmt):
        return DummyResult(self._plants)
    async def get(self, model, pk):
        # if asking for Farm, return self._single only if it's a Farm
        if model is Farm and isinstance(self._single, Farm):
            return self._single
        # if asking for Plant, return self._single only if it's a Plant
        if model is Plant and isinstance(self._single, Plant):
            return self._single
        return None
    async def add(self, obj):
        self.last_added = obj
    async def commit(self):
        pass
    async def refresh(self, obj):
        # simulate DB assigning an ID
        if getattr(obj, "id", None) is None:
            obj.id = 123
    async def delete(self, obj):
        pass

# --- tests ---

@pytest.mark.asyncio
async def test_create_plant_requires_existing_farm():
    sess = FakePlantSession(single=None)
    payload = {
        "name": "Lettuce",
        "type": "leaf",
        "growth_stage": "veg",
        "seeding_date": "2025-07-01T00:00:00Z",
        "region": "Bangalore",
        "location_description": "Greenhouse",
        "target_ph_min": 5.5,
        "target_ph_max": 6.5,
        "target_tds_min": 300,
        "target_tds_max": 700,
    }
    with pytest.raises(HTTPException) as exc:
        await create_plant(farm_id=42, payload=payload, db=sess)
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_create_and_list_plants_success():
    farm = Farm(id=5, owner_id=1, name="FarmX", address="Addr", latitude=0, longitude=0)
    plant = Plant(
        id=None,
        farm_id=5,
        name="Tomato",
        type="fruit",
        growth_stage="flower",
        seeding_date="2025-06-15T00:00:00Z",
        region="Bangalore",
        location_description="Greenhouse",
        target_ph_min=5.8,
        target_ph_max=6.2,
        target_tds_min=400,
        target_tds_max=800
    )
    sess = FakePlantSession(plants=[plant], single=farm)
    # create
    payload = {
        "name": plant.name,
        "type": plant.type,
        "growth_stage": plant.growth_stage,
        "seeding_date": plant.seeding_date,
        "region": plant.region,
        "location_description": plant.location_description,
        "target_ph_min": plant.target_ph_min,
        "target_ph_max": plant.target_ph_max,
        "target_tds_min": plant.target_tds_min,
        "target_tds_max": plant.target_tds_max,
    }
    new = await create_plant(farm_id=5, payload=payload, db=sess)
    assert isinstance(new, Plant)
    assert new.farm_id == 5

    # list
    plants = await list_plants_by_farm(farm_id=5, db=sess)
    assert plants == [plant]

@pytest.mark.asyncio
async def test_get_plant_by_id_not_found():
    sess = FakePlantSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await get_plant_by_id(99, db=sess)
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_delete_plant_success_and_missing():
    # delete when missing
    sess1 = FakePlantSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await delete_plant(1, db=sess1)
    assert exc.value.status_code == 404

    # delete when exists
    p = Plant(id=13, farm_id=5, name="Herb", type="herb", growth_stage="seedling",
              seeding_date="2025-07-10T00:00:00Z", region="R", location_description="Home",
              target_ph_min=6.0, target_ph_max=7.0, target_tds_min=200, target_tds_max=600)
    sess2 = FakePlantSession(single=p)
    out = await delete_plant(13, db=sess2)
    assert out == {"message": "Plant deleted successfully"}


----- tests/test_subscriptions_flow.py -----
# tests/test_subscriptions_flow.py
import datetime as _dt
from typing import Tuple

import pytest
from httpx import AsyncClient

from app.main import app
from app.models import PaymentStatus, SubscriptionPlan
from app.core.database import AsyncSessionLocal

# ─────────────────────────────────────────────────────────────────────────────
# Helpers / overrides
# ─────────────────────────────────────────────────────────────────────────────
class _DummyAdmin:
    id = 1
    role = "superadmin"
    email = "root@example.com"
    hashed_password = "x"

async def _always_admin() -> _DummyAdmin:
    return _DummyAdmin

def _override_admin_dep() -> None:
    """Force all @admin routes to succeed."""
    from app.dependencies import get_current_admin
    app.dependency_overrides[get_current_admin] = _always_admin


# ─────────────────────────────────────────────────────────────────────────────
# Fixtures
# ─────────────────────────────────────────────────────────────────────────────
@pytest.fixture
async def new_user(async_client: AsyncClient) -> Tuple[str, dict]:
    """
    Create a fresh user via the real signup endpoint,
    return (token, headers).
    """
    payload = {
        "email": "sub@test.io",
        "password": "Pwd!2345",
        "first_name": "Test",
        "last_name": "User",
        "phone": "1234567890",
        "address": "123 Main St",
        "city": "Testville",
        "state": "TS",
        "country": "Testland",
        "postal_code": "000001",
    }
    resp = await async_client.post("/api/v1/auth/signup", json=payload)
    assert resp.status_code == 201
    token = resp.json()["access_token"]
    return token, {"Authorization": f"Bearer {token}"}


@pytest.fixture
async def plan_id() -> int:
    """
    Insert a plan directly into the test DB with device_limit=1,
    return its ID.
    """
    async with AsyncSessionLocal() as db:
        plan = SubscriptionPlan(
            name="30-Day-Basic",
            device_types=["dosing_unit"],
            device_limit=1,
            duration_days=30,
            price_cents=10000,
            created_by=1,
        )
        db.add(plan)
        await db.commit()
        await db.refresh(plan)
        return plan.id


@pytest.fixture
async def device(async_client: AsyncClient, new_user: Tuple[str, dict]) -> str:
    """
    Register a mock dosing unit (via MockController).
    """
    _, hdrs = new_user
    resp = await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "AA:BB:CC",
            "name": "Mock Doser",
            "type": "dosing_unit",
            "http_endpoint": "http://doser",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "Chem"}],
        },
        headers=hdrs,
    )
    assert resp.status_code == 201
    return resp.json()["id"]


# ─────────────────────────────────────────────────────────────────────────────
# 1) ADMIN: CRUD SUBSCRIPTION PLANS
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_admin_plan_crud(async_client: AsyncClient):
    _override_admin_dep()
    hdr = {"Authorization": "Bearer admin-token"}

    # Create
    create = await async_client.post(
        "/admin/plans/",
        json={
            "name": "Basic",
            "device_types": ["dosing_unit"],
            "device_limit": 2,
            "duration_days": 15,
            "price_cents": 5000,
        },
        headers=hdr,
    )
    assert create.status_code == 201
    plan = create.json()
    pid = plan["id"]
    assert plan["name"] == "Basic"

    # List
    lst = await async_client.get("/admin/plans/", headers=hdr)
    assert lst.status_code == 200
    assert any(p["id"] == pid for p in lst.json())

    # Retrieve
    get1 = await async_client.get(f"/admin/plans/{pid}", headers=hdr)
    assert get1.status_code == 200
    assert get1.json()["device_limit"] == 2

    # Update
    upd = await async_client.put(
        f"/admin/plans/{pid}",
        json={"name": "Pro", "price_cents": 6000},
        headers=hdr,
    )
    assert upd.status_code == 200
    assert upd.json()["name"] == "Pro"

    # Delete
    rem = await async_client.delete(f"/admin/plans/{pid}", headers=hdr)
    assert rem.status_code == 204
    assert (await async_client.get(f"/admin/plans/{pid}", headers=hdr)).status_code == 404


# ─────────────────────────────────────────────────────────────────────────────
# 2) USER: VIEW AVAILABLE PLANS
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_user_can_list_plans(async_client: AsyncClient, new_user, plan_id):
    _, hdrs = new_user
    r = await async_client.get("/api/v1/plans/", headers=hdrs)
    assert r.status_code == 200
    assert any(p["id"] == plan_id for p in r.json())


# ─────────────────────────────────────────────────────────────────────────────
# 3) PURCHASE FLOW (PENDING → PROCESSING → COMPLETED)
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_full_purchase_and_activation(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # Create order
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    assert PaymentStatus(order["status"]) is PaymentStatus.PENDING
    assert order["qr_code_url"].endswith(".png")
    expires = _dt.datetime.fromisoformat(order["expires_at"].rstrip("Z"))
    assert expires > _dt.datetime.utcnow()

    # Upload proof
    up = await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("proof.png", b"\xFF\xD8\xFF", "image/png")},
    )
    assert up.status_code == 200
    assert up.json()["screenshot_path"].endswith(".png")

    # Confirm → PROCESSING
    conf = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "TXN-001"},
        headers=hdrs,
    )
    assert PaymentStatus(conf.json()["status"]) is PaymentStatus.PROCESSING

    # Admin Approve → COMPLETED
    done = await async_client.post(
        f'/admin/payments/approve/{order["id"]}',
        headers={"Authorization": "Bearer admin-token"},
    )
    assert PaymentStatus(done.json()["status"]) is PaymentStatus.COMPLETED

    # Subscription appears & is active
    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    assert len(subs) == 1
    s = subs[0]
    assert s["device_id"] == device
    assert s["active"] is True
    start = _dt.datetime.fromisoformat(s["start_date"].rstrip("Z"))
    end = _dt.datetime.fromisoformat(s["end_date"].rstrip("Z"))
    assert (end - start).days == 30
    assert s["device_limit"] == 1


# ─────────────────────────────────────────────────────────────────────────────
# 4) GUARD-RAILS
#    a) confirm without upload → 400
#    b) double-confirm → 400
#    c) unauthenticated admin approve → 401/403
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_confirm_without_screenshot_fails(async_client: AsyncClient, new_user, plan_id, device):
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "NO-PIC"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "upload" in r.json()["detail"].lower()


@pytest.mark.asyncio
async def test_double_confirm_is_idempotent(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("p.jpg", b"IMG", "image/jpeg")},
    )
    # first confirm
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "A"},
        headers=hdrs,
    )
    # second confirm → 400
    r2 = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "B"},
        headers=hdrs,
    )
    assert r2.status_code == 400
    assert "current status" in r2.json()["detail"].lower()


@pytest.mark.asyncio
async def test_unauthenticated_admin_approve_fails(async_client: AsyncClient, new_user, plan_id, device):
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("s.png", b"BIN", "image/png")},
    )
    await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "X"},
        headers=hdrs,
    )

    r = await async_client.post(f'/admin/payments/approve/{order["id"]}')
    assert r.status_code in (401, 403)


# ─────────────────────────────────────────────────────────────────────────────
# 5) REJECT FLOW
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_reject_pending_order(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("f.jpg", b"PIC", "image/jpeg")},
    )
    rej = await async_client.post(
        f'/admin/payments/reject/{order["id"]}',
        headers={"Authorization": "Bearer admin-token"},
    )
    assert PaymentStatus(rej.json()["status"]) is PaymentStatus.FAILED


# ─────────────────────────────────────────────────────────────────────────────
# 6) EXPIRY LOGIC
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_order_expiry_blocks_confirm(async_client: AsyncClient, monkeypatch, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    import app.routers.payments as pay_mod
    orig = pay_mod.datetime.utcnow
    # shift “now” back 31m so expires < now
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(lambda: orig() - _dt.timedelta(minutes=31)))

    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()

    # restore real time
    monkeypatch.setattr(pay_mod.datetime, "utcnow", staticmethod(orig))

    await async_client.post(
        f'/api/v1/payments/upload/{order["id"]}',
        headers=hdrs,
        files={"file": ("e.png", b"IMG", "image/png")},
    )
    r = await async_client.post(
        f'/api/v1/payments/confirm/{order["id"]}',
        json={"upi_transaction_id": "LATE"},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "expired" in r.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 7) DEVICE-LINKING & LIMIT ENFORCEMENT
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_cannot_link_more_than_limit(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # purchase & activate
    order = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{order['id']}", headers=hdrs, files={"file":("x.jpg",b"BIN","image/jpeg")})
    await async_client.post(f"/api/v1/payments/confirm/{order['id']}", json={"upi_transaction_id":"1"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{order['id']}", headers={"Authorization":"Bearer admin-token"})

    subs = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()
    sid = subs[0]["id"]

    # register a _second_ device
    d2 = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "DD:EE:FF",
            "name": "Extra",
            "type": "dosing_unit",
            "http_endpoint": "http://extra",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "X"}],
        },
        headers=hdrs,
    )).json()["id"]

    # FAIL: over the plan’s device_limit=1
    r = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": d2},
        headers=hdrs,
    )
    assert r.status_code == 400
    assert "limit" in r.json()["detail"].lower()


# ─────────────────────────────────────────────────────────────────────────────
# 8) EXTENSION FLOW (INCREASE LIMIT + EXTEND PERIOD)
# ─────────────────────────────────────────────────────────────────────────────
@pytest.mark.asyncio
async def test_extension_and_then_link_additional(async_client: AsyncClient, new_user, plan_id, device):
    _override_admin_dep()
    _, hdrs = new_user

    # 1) initial purchase
    ord1 = (await async_client.post(
        "/api/v1/payments/create",
        json={"device_id": device, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{ord1['id']}", headers=hdrs, files={"file":("a","b","i")})
    await async_client.post(f"/api/v1/payments/confirm/{ord1['id']}", json={"upi_transaction_id":"E1"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ord1['id']}", headers={"Authorization":"Bearer admin-token"})

    subs1 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    sid = subs1["id"]
    start1 = _dt.datetime.fromisoformat(subs1["start_date"].rstrip("Z"))
    end1 = _dt.datetime.fromisoformat(subs1["end_date"].rstrip("Z"))
    assert (end1 - start1).days == 30
    assert subs1["device_limit"] == 1

    # 2) extension payment → bump limit to 2 & +30d
    ext = (await async_client.post(
        "/api/v1/payments/create",
        json={"subscription_id": sid, "plan_id": plan_id},
        headers=hdrs,
    )).json()
    await async_client.post(f"/api/v1/payments/upload/{ext['id']}", headers=hdrs, files={"file":("c","d","i")})
    await async_client.post(f"/api/v1/payments/confirm/{ext['id']}", json={"upi_transaction_id":"E2"}, headers=hdrs)
    await async_client.post(f"/admin/payments/approve/{ext['id']}", headers={"Authorization":"Bearer admin-token"})

    subs2 = (await async_client.get("/api/v1/subscriptions/", headers=hdrs)).json()[0]
    start2 = _dt.datetime.fromisoformat(subs2["start_date"].rstrip("Z"))
    end2 = _dt.datetime.fromisoformat(subs2["end_date"].rstrip("Z"))
    assert subs2["device_limit"] == 2
    assert (end2 - start2).days == 60

    # 3) now linking a second device succeeds
    d3 = (await async_client.post(
        "/api/v1/devices/dosing",
        json={
            "mac_id": "GG:HH:II",
            "name": "Extra2",
            "type": "dosing_unit",
            "http_endpoint": "http://extra2",
            "pump_configurations": [{"pump_number": 1, "chemical_name": "Y"}],
        },
        headers=hdrs,
    )).json()["id"]

    link = await async_client.post(
        f"/api/v1/subscriptions/{sid}/devices",
        json={"device_id": d3},
        headers=hdrs,
    )
    assert link.status_code == 200
    assert link.json()["device_id"] == d3


----- tests/test_llm_service.py -----
# tests/test_llm_service.py
"""
Integration-style tests for app.services.llm
-------------------------------------------

• If USE_OLLAMA=true (or TESTING=1) we hit your local Ollama server.
  Tests are skipped if it isn’t reachable.
• Otherwise we hit OpenAI.  Skipped if OPENAI_API_KEY is missing.
• SERPER_API_KEY tests for build_plan_prompt are also skipped if missing.
"""
from __future__ import annotations
import os
import json
import pytest
import httpx
from dotenv import load_dotenv

# 1) Load .env and THEN import llm so it sees the right env vars
ROOT = os.path.dirname(os.path.dirname(__file__))
load_dotenv(os.path.join(ROOT, ".env"))

import importlib
import app.services.llm as llm
importlib.reload(llm)  # ensure module picks up freshly loaded env vars

from app.services.llm import (
    enhance_query,
    parse_json_response,
    parse_ollama_response,
    parse_openai_response,
    validate_llm_response,
    build_dosing_prompt,
    build_plan_prompt,
    call_llm_async,
)

# ───────────────────────────────────────────────────────────────────────────── #
# Helper utilities                                                             #
# ───────────────────────────────────────────────────────────────────────────── #

async def _ollama_available() -> bool:
    base = llm.OLLAMA_URL.split("/api/")[0]
    try:
        async with httpx.AsyncClient(timeout=2) as client:
            r = await client.get(f"{base}/api/tags")
            return r.status_code == 200
    except Exception:
        return False

def _openai_key_present() -> bool:
    return bool(os.getenv("OPENAI_API_KEY"))

def _serper_key_present() -> bool:
    return bool(os.getenv("SERPER_API_KEY"))

# ───────────────────────────────────────────────────────────────────────────── #
# 1. Pure utility functions (no I/O)                                           #
# ───────────────────────────────────────────────────────────────────────────── #

def test_enhance_query_adds_context() -> None:
    q = "Adjust dose"
    profile = {
        "plant_name": "Rose",
        "plant_type": "Flower",
        "growth_stage": "Veg",
        "seeding_date": "2020",
        "location": "Farm",
    }
    out = enhance_query(q, profile)
    assert "Please consider that the plant 'Rose'" in out

def test_enhance_query_no_duplicate_location() -> None:
    q = "dose in Farm"
    profile = {"location": "Farm"}
    out = enhance_query(q, profile)
    assert "Please consider that the plant" not in out

def test_parse_json_response_valid() -> None:
    s = "{ 'a': 1, 'b': 2 } trailing"
    res = parse_json_response(s)
    assert res == {"a": 1, "b": 2}

def test_parse_json_response_malformed() -> None:
    with pytest.raises(ValueError):
        parse_json_response("no json here")

def test_parse_ollama_response_removes_think() -> None:
    raw = "<think>debug</think>{\"x\":1}"
    cleaned = parse_ollama_response(raw)
    assert cleaned == "{\"x\":1}"

def test_parse_openai_response_good() -> None:
    raw = "prefix {\"y\":2} suffix"
    out = parse_openai_response(raw)
    assert out == json.dumps({"y": 2})

def test_parse_openai_response_nested() -> None:
    raw = "foo {\"a\":{\"b\":2}} bar"
    out = parse_openai_response(raw)
    assert out == json.dumps({"a": {"b": 2}})

def test_parse_openai_response_bad() -> None:
    with pytest.raises(ValueError):
        parse_openai_response("no braces at all")

def test_validate_llm_response_good() -> None:
    payload = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": 10, "reasoning": "ok"}
        ]
    }
    validate_llm_response(payload)  # should not raise

def test_validate_llm_response_missing_actions() -> None:
    with pytest.raises(ValueError):
        validate_llm_response({})

def test_validate_llm_response_bad_dose() -> None:
    bad = {
        "actions": [
            {"pump_number": 1, "chemical_name": "A", "dose_ml": -5, "reasoning": "oops"}
        ]
    }
    with pytest.raises(ValueError):
        validate_llm_response(bad)

# ───────────────────────────────────────────────────────────────────────────── #
# 2. Prompt builders                                                           #
# ───────────────────────────────────────────────────────────────────────────── #

class _DummyDevice:
    def __init__(self) -> None:
        self.id = "d1"
        self.pump_configurations = [
            {
                "pump_number": 1,
                "chemical_name": "Chem-A",
                "chemical_description": "Desc",
            }
        ]

@pytest.mark.asyncio
async def test_build_dosing_prompt_contains_expected_sections() -> None:
    dev = _DummyDevice()
    sensor = {"ph": 6.5, "tds": 300}
    profile = {
        "plant_name": "P",
        "plant_type": "T",
        "growth_stage": "G",
        "seeding_date": "2020",
        "region": "R",
        "location": "L",
        "target_ph_min": 5,
        "target_ph_max": 7,
        "target_tds_min": 100,
        "target_tds_max": 500,
        "dosing_schedule": {},
    }
    prompt = await build_dosing_prompt(dev, sensor, profile)
    assert "Pump 1: Chem-A" in prompt
    assert "- pH: 6.5" in prompt

@pytest.mark.asyncio
async def test_build_dosing_prompt_raises_when_no_pumps() -> None:
    class NoPump:
        id = "x"
        pump_configurations = None

    with pytest.raises(ValueError):
        await build_dosing_prompt(NoPump(), {"ph": 7, "tds": 100}, {})

@pytest.mark.asyncio
async def test_build_plan_prompt_live_search() -> None:
    if not _serper_key_present():
        pytest.skip("SERPER_API_KEY missing – skipping live Serper test")

    sensor_data = {"P": 1, "TDS": 2}
    profile = {
        "plant_name": "TestPlant",
        "plant_type": "Veggie",
        "growth_stage": "Seedling",
        "seeding_date": "2023-01-01",
        "region": "Europe",
        "location": "Berlin",
    }
    prompt = await build_plan_prompt(sensor_data, profile, "optimal growth")
    assert "Detailed Search Insights" in prompt

# ───────────────────────────────────────────────────────────────────────────── #
# 3. Unified integration test                                                #
# ───────────────────────────────────────────────────────────────────────────── #

@pytest.mark.asyncio
async def test_call_llm_async_integration() -> None:
    prompt = 'Return exactly this JSON: {"foo":42}'
    if llm.USE_OLLAMA:
        # Ollama must be reachable
        available = await _ollama_available()
        assert available, "Local Ollama server must be running for this integration test"
        parsed, raw = await call_llm_async(prompt, llm.MODEL_1_5B)
        assert isinstance(parsed, dict)
        assert parsed["foo"] == 42
        # raw should be the compact JSON
        assert raw.strip() == json.dumps(parsed, separators=(",", ":"))
    else:
        # OPENAI_API_KEY must be present
        assert _openai_key_present(), "OPENAI_API_KEY must be set for OpenAI integration test"
        model = os.getenv("GPT_MODEL") or "gpt-3.5-turbo"
        parsed, raw = await call_llm_async(prompt, model)
        assert isinstance(parsed, dict)
        assert parsed["foo"] == 42
        # raw must be parseable to the same dict
        assert json.loads(raw) == parsed


----- tests/test_devices.py -----
# tests/test_device_controller.py
import pytest
import httpx
from app.services.device_controller import DeviceController, get_device_controller

# ----------------------------------------
# Helpers for mocking HTTPX AsyncClient
# ----------------------------------------
class DummyResponse:
    def __init__(self, status_code: int, json_data: dict):
        self.status_code = status_code
        self._json = json_data
    def json(self) -> dict:
        return self._json
    def raise_for_status(self):
        if self.status_code >= 400:
            raise httpx.HTTPStatusError(f"Status code {self.status_code}", request=None, response=self)

class FakeAsyncClient:
    def __init__(self, responses: dict[str, tuple[int, dict]]):
        # responses: path suffix -> (status_code, json_data)
        self._responses = responses
    async def __aenter__(self):
        return self
    async def __aexit__(self, exc_type, exc, tb):
        pass
    async def get(self, url: str, *args, **kwargs):
        for path, (code, data) in self._responses.items():
            if url.endswith(path):
                return DummyResponse(code, data)
        return DummyResponse(404, {})
    async def post(self, url: str, *args, json=None, **kwargs):
        for path, (code, data) in self._responses.items():
            if url.endswith(path):
                return DummyResponse(code, data)
        return DummyResponse(404, {})

# ----------------------------------------
# Global fixture: patch httpx.AsyncClient
# ----------------------------------------
@pytest.fixture(autouse=True)
def patch_async_client(monkeypatch):
    # Default mock behavior for all endpoints
    default_responses = {
        '/discovery': (200, {'device_id': 'dev123', 'type': 'dosing_unit', 'version': '1.2.3'}),
        '/version': (200, {'version': '2.0.0'}),
        '/monitor': (200, {'ph': 7.2, 'tds': 450.0}),
        '/pump': (200, {'message': 'pump executed'}),
        '/dose_monitor': (200, {'message': 'combined pump executed'}),
        '/pump_calibration': (200, {'message': 'dosing cancelled'}),
        '/state': (200, {'device_id': 'valve456', 'valves': [{'id': 1, 'state': 'on'}]}),
        '/toggle': (200, {'new_state': 'off'}),
    }
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(default_responses))

# ----------------------------------------
# Test cases for discovery
# ----------------------------------------
@pytest.mark.asyncio
async def test_discover_via_discovery_endpoint():
    """
    Ensure discover() returns primary discovery JSON when /discovery succeeds.
    """
    dc = get_device_controller('http://mock-device')
    data = await dc.discover()
    assert data['device_id'] == 'dev123'
    assert data['type'] == 'dosing_unit'
    assert data['version'] == '1.2.3'
    assert data['ip'] == 'http://mock-device'

@pytest.mark.asyncio
async def test_discover_fallback_to_state_on_discovery_failure(monkeypatch):
    """
    Simulate /discovery failure and verify fallback to /state for valve_controller.
    """
    # Patch AsyncClient with only /state
    responses = {'/discovery': (500, {}), '/state': (200, {'device_id': 'valve789', 'valves': [{'id': 2, 'state': 'off'}]})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('192.168.0.10')
    result = await dc.discover()
    assert result['device_id'] == 'valve789'
    assert result['type'] == 'valve_controller'
    assert isinstance(result['valves'], list)
    assert result['valves'][0]['id'] == 2
    assert result['ip'] == '192.168.0.10'

# ----------------------------------------
# Test cases for version endpoint
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_version_prefers_version_endpoint():
    """
    get_version() should return /version when available.
    """
    dc = get_device_controller('device-ip')
    version = await dc.get_version()
    assert version == '2.0.0'

@pytest.mark.asyncio
async def test_get_version_fallbacks_to_discover_on_error(monkeypatch):
    """
    If /version returns error, get_version() should fallback to discover().
    """
    responses = {'/version': (404, {}), '/discovery': (200, {'device_id': 'd1', 'version': '3.3.3'})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('devip')
    version = await dc.get_version()
    assert version == '3.3.3'

# ----------------------------------------
# Test cases for sensor readings
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_sensor_readings_success():
    """
    get_sensor_readings() should parse ph and tds correctly.
    """
    dc = get_device_controller('devip')
    readings = await dc.get_sensor_readings()
    assert isinstance(readings, dict)
    assert readings['ph'] == pytest.approx(7.2)
    assert readings['tds'] == pytest.approx(450.0)

@pytest.mark.asyncio
async def test_get_sensor_readings_http_error(monkeypatch):
    """
    get_sensor_readings() should raise HTTPException on non-200.
    """
    responses = {'/monitor': (500, {'error': 'fail'})}
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *args, **kwargs: FakeAsyncClient(responses))

    dc = DeviceController('devip')
    with pytest.raises(httpx.HTTPStatusError):
        await dc.get_sensor_readings()

# ----------------------------------------
# Test cases for dosing operations
# ----------------------------------------
@pytest.mark.asyncio
async def test_execute_dosing_single_and_combined():
    """
    execute_dosing() should call /pump and /dose_monitor based on flag.
    """
    dc = get_device_controller('devip')
    single = await dc.execute_dosing(1, 100)
    assert single['message'] == 'pump executed'
    combined = await dc.execute_dosing(2, 50, combined=True)
    assert combined['message'] == 'combined pump executed'

@pytest.mark.asyncio
async def test_cancel_dosing_command():
    """
    cancel_dosing() should post to /pump_calibration with stop command.
    """
    dc = get_device_controller('devip')
    res = await dc.cancel_dosing()
    assert res['message'] == 'dosing cancelled'

# ----------------------------------------
# Test cases for valve state and toggle
# ----------------------------------------
@pytest.mark.asyncio
async def test_get_state_success():
    """
    get_state() should fetch full valve state JSON.
    """
    dc = get_device_controller('devip')
    state = await dc.get_state()
    assert state['device_id'] == 'valve456'
    assert isinstance(state['valves'], list)
    assert state['valves'][0]['state'] == 'on'

@pytest.mark.asyncio
async def test_toggle_valve_success():
    """
    toggle_valve() should post to /toggle and return new_state.
    """
    dc = get_device_controller('devip')
    result = await dc.toggle_valve(1)
    assert 'new_state' in result
    assert result['new_state'] == 'off'

# ----------------------------------------
# Test invalid inputs
# ----------------------------------------
@pytest.mark.asyncio
async def test_toggle_valve_invalid_channel(monkeypatch):
    """
    toggle_valve() should raise ValueError if channel not in 1-4.
    """
    dc = get_device_controller('devip')
    with pytest.raises(ValueError):
        # channel 0 is invalid
        await dc.toggle_valve(0)

@pytest.mark.asyncio
async def test_get_version_both_fail(monkeypatch):
    """If both /version and /discovery fail, get_version returns None."""
    class DR:
        def __init__(self, code): self.status_code=code
        def json(self): return {}
    class FC:
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def get(self, path, *a,**k):
            return DR(500)  # always error
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *a,**k: FC())
    dc = DeviceController("10.1.1.1")
    v = await dc.get_version()
    assert v is None

@pytest.mark.asyncio
async def test_execute_dosing_http_error(monkeypatch):
    """If the /pump endpoint returns 500, execute_dosing raises HTTPStatusError."""
    # arrange FakeAsyncClient whose /pump returns 500
    from app.services.device_controller import DeviceController
    class FR:
        def __init__(self,*a,**k): pass
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def post(self, url, *a, json=None, **k):
            return DummyResponse(500, {})
    monkeypatch.setattr(httpx, 'AsyncClient', lambda *a,**k: FR())
    dc = DeviceController("ip")
    with pytest.raises(httpx.HTTPStatusError):
        await dc.execute_dosing(1,100)

@pytest.mark.asyncio
async def test_toggle_valve_http_error(monkeypatch):
    """If /toggle returns 500, toggle_valve raises HTTPStatusError."""
    class FR:
        def __init__(self,*a,**k): pass
        async def __aenter__(self): return self
        async def __aexit__(self,*a): pass
        async def post(self, url, *a, json=None, **k):
            return DummyResponse(500,{})
    from app.services.device_controller import DeviceController
    monkeypatch.setattr(httpx,'AsyncClient',lambda *a,**k: FR())
    dc = DeviceController("ip")
    with pytest.raises(httpx.HTTPStatusError):
        await dc.toggle_valve(2)



----- tests/test_dose_manager.py -----
# tests/test_dose_manager.py
import pytest
from fastapi import HTTPException
from app.services.dose_manager import DoseManager

class DummyController:
    def __init__(self, *args, **kw): pass
    async def execute_dosing(self, pump, amount, combined=False):
        return {"ok": True, "pump": pump, "amount": amount, "combined": combined}
    async def cancel_dosing(self):
        return {"cancelled": True}

@pytest.fixture(autouse=True)
def patch_controller(monkeypatch):
    # replace DeviceController inside DoseManager with our dummy
    monkeypatch.setattr("app.services.dose_manager.DeviceController", lambda *a, **k: DummyController())

dm = DoseManager()

@pytest.mark.asyncio
async def test_execute_dosing_empty_actions():
    with pytest.raises(ValueError):
        await dm.execute_dosing("dev1", "http://x", [], combined=False)

@pytest.mark.asyncio
async def test_execute_dosing_missing_fields():
    # action missing pump or dose
    with pytest.raises(ValueError):
        await dm.execute_dosing("dev1", "http://x", [{"foo":1}], combined=True)

@pytest.mark.asyncio
async def test_execute_dosing_success_single_and_combined():
    actions = [{"pump_number": 2, "dose_ml": 25}]
    res = await dm.execute_dosing("dev1", "http://x", actions, combined=False)
    assert res["status"] == "command_sent"
    assert res["device_id"] == "dev1"
    assert res["actions"] == actions
    # combined
    res2 = await dm.execute_dosing("dev1", "http://x", actions, combined=True)
    assert res2["status"] == "command_sent"
    assert res2["actions"] == actions

@pytest.mark.asyncio
async def test_cancel_dosing_idempotent():
    res = await dm.cancel_dosing("devX","http://x")
    assert res == {"status":"dosing_cancelled","device_id":"devX","response":{"cancelled":True}}

----- tests/test_farm_service.py -----
# tests/services/test_farm_service.py

import pytest
from fastapi import HTTPException
from types import SimpleNamespace

from app.services.farm_service import (
    create_farm,
    list_farms_for_user,
    get_farm_by_id,
    share_farm_with_user,
)
from app.models import Farm

# -------------------------------------------------------------------
# Fake session & result helpers
# -------------------------------------------------------------------

class DummyResult:
    def __init__(self, items):
        self._items = items
    def scalars(self):
        return self
    def all(self):
        return self._items

class FakeFarmSession:
    def __init__(self, farms=None, single=None):
        # farms: what execute() will return for list_farms_for_user
        # single: what get(Farm, pk) will return
        self._farms = farms or []
        self._single = single
        self.last_added = None
        self.committed = False

    async def execute(self, stmt):
        return DummyResult(self._farms)

    async def get(self, model, pk):
        return self._single

    async def add(self, obj):
        # record the exact object you tried to add
        self.last_added = obj

    async def commit(self):
        # record that commit() was called
        self.committed = True

    async def refresh(self, obj):
        # no-op for tests
        pass

# -------------------------------------------------------------------
# Tests
# -------------------------------------------------------------------

@pytest.mark.asyncio
async def test_create_farm_success():
    sess = FakeFarmSession()
    owner_id = 42
    payload = {
        "name": "Test Farm",
        "address": "123 Garden Lane",
        "latitude": 12.9716,
        "longitude": 77.5946
    }

    farm = await create_farm(owner_id=owner_id, payload=payload, db=sess)

    # it's a real ORM object
    assert isinstance(farm, Farm)
    assert farm.owner_id == owner_id
    assert farm.name == payload["name"]
    assert farm.address == payload["address"]
    assert pytest.approx(farm.latitude) == payload["latitude"]
    assert pytest.approx(farm.longitude) == payload["longitude"]

@pytest.mark.asyncio
async def test_get_farm_by_id_not_found():
    sess = FakeFarmSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await get_farm_by_id(99, db=sess)
    # 404 when missing
    assert exc.value.status_code == 404
    assert "not found" in exc.value.detail.lower()

@pytest.mark.asyncio
async def test_list_farms_for_user():
    f1 = Farm(id=1, owner_id=5, name="A", address="AddrA", latitude=0, longitude=0)
    f2 = Farm(id=2, owner_id=5, name="B", address="AddrB", latitude=1, longitude=1)
    sess = FakeFarmSession(farms=[f1, f2])

    farms = await list_farms_for_user(user_id=5, db=sess)

    # we get back exactly what we seeded
    assert farms == [f1, f2]

@pytest.mark.asyncio
async def test_share_farm_not_found():
    sess = FakeFarmSession(single=None)
    with pytest.raises(HTTPException) as exc:
        await share_farm_with_user(farm_id=5, user_id=11, db=sess)
    # still a 404 for missing farm
    assert exc.value.status_code == 404

@pytest.mark.asyncio
async def test_share_farm_success_records_and_returns_association():
    # prepare a farm
    farm = Farm(id=7, owner_id=3, name="Shared Farm", address="X", latitude=0, longitude=0)
    sess = FakeFarmSession(single=farm)
    sub_user_id = 99

    assoc = await share_farm_with_user(farm_id=7, user_id=sub_user_id, db=sess)

    # 1) check you added exactly that object to the session
    assert sess.last_added is assoc

    # 2) check you committed
    assert sess.committed is True

    # 3) and that the return has the right attributes
    assert isinstance(assoc, SimpleNamespace)
    assert assoc.farm_id == 7
    assert assoc.user_id == sub_user_id


