# app/routers/cloud.py
"""
Cloud-key management & device authentication.

• Every generated key is stored in the `cloud_keys` table (latest row is current).
• Keys survive process restarts and are shared across all workers.
• `/authenticate` simply checks the supplied key and returns a random token.
"""

from __future__ import annotations

import logging
import secrets
from datetime import timezone, datetime

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.schemas import (
    CloudAuthenticationRequest,
    CloudAuthenticationResponse,
    DosingCancellationRequest,
)
from app.dependencies import get_current_admin
from app.core.database import get_db
from app.models import Base
from sqlalchemy import Column, Integer, String, DateTime
from app.models import CloudKey
logger = logging.getLogger(__name__)
router = APIRouter()

# ─────────────────────────────────────────────────────────────────────────────
# 2.  Helper – fetch the newest key
# ─────────────────────────────────────────────────────────────────────────────
async def _get_current_key(db: AsyncSession) -> str | None:
    row = await db.scalar(
        select(CloudKey).order_by(CloudKey.id.desc()).limit(1)
    )
    return row.key if row else None


# ─────────────────────────────────────────────────────────────────────────────
# 3.  Public endpoints
# ─────────────────────────────────────────────────────────────────────────────
@router.post("/authenticate", response_model=CloudAuthenticationResponse)
async def authenticate_cloud(
    payload: CloudAuthenticationRequest,
    db: AsyncSession = Depends(get_db),
):
    """
    Device → cloud authentication.

    A device posts `{device_id, cloud_key}`.
    If the key matches the latest one generated by an admin, return a token.
    """
    current_key = await _get_current_key(db)
    if payload.cloud_key != current_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid cloud key",
        )

    token = secrets.token_hex(16)  # (replace with JWT if needed)
    logger.info(
        "Device %s authenticated OK – issued token %s", payload.device_id, token
    )
    return CloudAuthenticationResponse(
        token=token,
        message="Authentication successful",
    )


@router.post("/verify_key")
async def verify_cloud_key(
    payload: CloudAuthenticationRequest,
    db: AsyncSession = Depends(get_db),
):
    """
    Quick check used by devices/portal: “is this key still valid?”.
    """
    if payload.cloud_key == await _get_current_key(db):
        return {"status": "valid", "message": "Cloud key is valid"}
    raise HTTPException(status_code=401, detail="Invalid cloud key")


@router.post("/dosing_cancel")
async def dosing_cancel(request: DosingCancellationRequest):
    """
    Webhook target for a device reporting a cancelled dosing event.
    """
    if request.event != "dosing_cancelled":
        raise HTTPException(400, "Invalid event type")
    logger.info("Dosing cancelled – device=%s", request.device_id)
    return {"message": "Dosing cancellation received", "device_id": request.device_id}


# ─────────────────────────────────────────────────────────────────────────────
# 4.  Admin endpoints
# ─────────────────────────────────────────────────────────────────────────────
@router.post(
    "/admin/generate_cloud_key",
    dependencies=[Depends(get_current_admin)],
)
async def generate_cloud_key(db: AsyncSession = Depends(get_db)):
    """
    Mint a **new** cloud key and make it the active one.

    Older keys remain in the table (audit trail) but are no longer accepted.
    """
    new_key = secrets.token_hex(16)
    db.add(CloudKey(key=new_key))
    await db.commit()
    logger.info("New cloud key generated: %s", new_key)
    return {"cloud_key": new_key}
